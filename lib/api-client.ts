// RAG Backend API Client
export interface UploadResponse {
  batch_id: string
  count: number
}

export interface QueryResponse {
  answer: string;
  sources?: Array<{
    document: string;
    text: string;
    score: number;
  }>;
}

export interface BackendDocument {
  id: string;
  name: string;
  size: number;
  type: string;
  uploadDate: string;
  status: string;
  progress: number;
  language: string;
  themes: string[];
  keywords: string[];
  demographics: string[];
  summary?: string;
  insights?: string;
  keyInsights?: string[]; // New field from backend
  mainTopics?: string[]; // New field from backend
  sentiment?: string; // New field from backend
  readingLevel?: string; // New field from backend
  content?: string; // New field from backend
  path: string;
}

export interface AvailableModel {
  name: string;
  provider: string;
  displayName: string;
  description?: string;
  isAvailable: boolean;
  isLocal?: boolean;
}

export interface ModelProvider {
  name: string;
  displayName: string;
  isAvailable: boolean;
  models: AvailableModel[];
}

export interface AICuration {
  id: string;
  title: string;
  description: string;
  documentCount: number;
  lastUpdated: string;
  status: 'active' | 'stale' | 'updating' | 'archived';
  confidence: number;
  autoGenerated: boolean;
  documentIds: string[];
  keywords: string[];
  topicKeywords?: string[]; // For backward compatibility
}

export interface Conversation {
  id: string;
  title: string;
  created_at: string;
  updated_at: string;
  message_count: number;
  is_archived: boolean;
  is_pinned: boolean;
  tags: string[];
  total_tokens_used: number;
  primary_provider?: string;
  primary_model?: string;
  document_ids_referenced: string[];
}

export interface Message {
  id: string;
  conversation_id: string;
  role: string; // "user", "assistant", "curation", "summary"
  content: string;
  created_at: string;
  provider_used?: string;
  model_used?: string;
  document_ids: string[];
  sources: Array<{
    document: string;
    text: string;
    score: number;
  }>;
  context_mode?: string;
  metadata: Record<string, any>;
  tokens_used?: number;
  response_time_ms?: number;
  curation_id?: string;
  summary_id?: string;
  is_edited: boolean;
}

export interface ConversationWithMessages {
  conversation: Conversation;
  messages: Message[];
}

export interface ConversationStats {
  total_conversations: number;
  active_conversations: number;
  archived_conversations: number;
  total_messages: number;
  total_tokens_used: number;
}

export interface ConversationSettings {
  auto_save_conversations: boolean;
  auto_generate_titles: boolean;
  max_conversations: number;
  auto_archive_after_days: number;
  default_provider: string;
  default_model: string;
  save_curation_conversations: boolean;
  save_summary_conversations: boolean;
}

export interface CurationSettings {
  autoRefresh: boolean;
  onAdd: 'full' | 'incremental' | 'manual';
  onDelete: 'auto_clean' | 'keep_stale' | 'prompt';
  changeThreshold: number;
  maxCurations: number;
  minDocumentsPerCuration: number;
}

export interface CurationStatus {
  totalCurations: number;
  freshCurations: number;
  staleCurations: number;
  lastGenerated: string | null;
  documentsAnalyzed: number;
}

export interface WebSocketMessage {
  type: 'queued' | 'processing' | 'completed' | 'error' | 
        'bulk_upload_started' | 'tier1_initiated' | 'priority_processing_started' | 
        'rag_available' | 'tier2_initiated' | 'background_processing_started' | 
        'background_file_completed' | 'parallel_progress' | 'task_completed' |
        'priority_processing_error' | 'background_processing_error'
  data: any
  timestamp: string
}

export class RagApiClient {
  private baseUrl: string
  private provider: string
  private hybrid: boolean
  private maxFileSize: number
  private bulkUploadThreshold: number
  
  // Enhanced caching for multiple data types
  private providersCache: ModelProvider[] | null = null
  private providersCacheTimestamp: number = 0
  private providersCachePromise: Promise<ModelProvider[]> | null = null
  private readonly PROVIDERS_CACHE_DURATION = 5 * 60 * 1000 // 5 minutes
  
  // Document cache for faster navigation
  private documentsCache: BackendDocument[] | null = null
  private documentsCacheTimestamp: number = 0
  private documentsCachePromise: Promise<BackendDocument[]> | null = null
  private readonly DOCUMENTS_CACHE_DURATION = 2 * 60 * 1000 // 2 minutes
  
  // Curations cache
  private curationsCache: AICuration[] | null = null
  private curationsCacheTimestamp: number = 0
  private curationsCachePromise: Promise<AICuration[]> | null = null
  private readonly CURATIONS_CACHE_DURATION = 3 * 60 * 1000 // 3 minutes

  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_RAG_API_URL || 'https://sixth-vault.com/api'
    this.provider = process.env.NEXT_PUBLIC_RAG_PROVIDER || 'gemini'
    this.hybrid = process.env.NEXT_PUBLIC_RAG_HYBRID === 'true'
    this.maxFileSize = parseInt(process.env.NEXT_PUBLIC_MAX_FILE_SIZE || '50000000')
    this.bulkUploadThreshold = parseInt(process.env.NEXT_PUBLIC_BULK_UPLOAD_THRESHOLD || '3')
  }

  private getAuthHeaders(): HeadersInit {
    // Get token from cookie with enhanced error handling and debugging
    let token: string | undefined
    
    try {
      // Check if we're in a browser environment
      if (typeof document === 'undefined') {
        console.warn('üö® API Client: Not in browser environment, no cookies available')
        return {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          'ngrok-skip-browser-warning': 'true'
        }
      }

      // Enhanced cookie parsing logic with multiple fallback strategies
      const rawCookies = document.cookie
      console.log('üîç API Client: Raw cookies string:', rawCookies)
      
      if (!rawCookies || rawCookies.trim() === '') {
        console.warn('üö® API Client: No cookies found in document.cookie')
        return {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          'ngrok-skip-browser-warning': 'true'
        }
      }

      // Strategy 1: Standard cookie parsing
      const cookies = rawCookies.split(';').map(cookie => cookie.trim())
      let authCookie = cookies.find(cookie => cookie.startsWith('auth-token='))
      
      // Strategy 2: If not found, try without trimming (in case of edge cases)
      if (!authCookie) {
        const rawCookieArray = rawCookies.split(';')
        authCookie = rawCookieArray.find(cookie => cookie.includes('auth-token='))
      }
      
      // Strategy 3: Direct string search as last resort
      if (!authCookie && rawCookies.includes('auth-token=')) {
        const startIndex = rawCookies.indexOf('auth-token=')
        const endIndex = rawCookies.indexOf(';', startIndex)
        authCookie = endIndex === -1 
          ? rawCookies.substring(startIndex)
          : rawCookies.substring(startIndex, endIndex)
      }
      
      console.log('üîç API Client: Cookie parsing strategies:')
      console.log('  - Total cookies found:', cookies.length)
      console.log('  - Auth cookie found:', !!authCookie)
      console.log('  - Auth cookie value:', authCookie)
      
      if (authCookie) {
        // Extract token value after the '=' sign with enhanced validation
        const equalIndex = authCookie.indexOf('=')
        if (equalIndex !== -1 && equalIndex < authCookie.length - 1) {
          const tokenValue = authCookie.substring(equalIndex + 1).trim()
          
          if (tokenValue && 
              tokenValue !== 'undefined' && 
              tokenValue !== 'null' && 
              tokenValue !== '' &&
              tokenValue.length > 10) {
            
            // Try to decode URI component in case the token was encoded
            try {
              const decodedToken = decodeURIComponent(tokenValue)
              // Validate decoded token
              if (decodedToken && 
                  decodedToken !== 'undefined' && 
                  decodedToken !== 'null' && 
                  decodedToken.trim() !== '' &&
                  decodedToken.length > 10) {
                token = decodedToken
                console.log('‚úÖ API Client: Successfully decoded token')
              } else {
                token = tokenValue // Use raw token if decoded is invalid
                console.log('üîß API Client: Using raw token (decode validation failed)')
              }
            } catch (decodeError) {
              console.warn('üîß API Client: Token decode failed, using raw token:', decodeError)
              token = tokenValue
            }
          } else {
            console.warn('üö® API Client: Invalid token value found:', {
              exists: !!tokenValue,
              notUndefined: tokenValue !== 'undefined',
              notNull: tokenValue !== 'null',
              notEmpty: tokenValue !== '',
              lengthValid: tokenValue.length > 10,
              actualLength: tokenValue.length
            })
          }
        } else {
          console.warn('üö® API Client: Malformed auth cookie (no = found or empty value):', authCookie)
        }
      } else {
        console.warn('üö® API Client: No auth-token cookie found in:', rawCookies)
      }
      
      console.log('üîç API Client: Final token extraction result:')
      console.log('  - Token extracted:', !!token)
      console.log('  - Token length:', token?.length || 0)
      console.log('  - Token preview:', token ? token.substring(0, 20) + '...' : 'none')
      
    } catch (error) {
      console.error('üö® API Client: Error reading auth token from cookies:', error)
      console.log('üç™ API Client: Raw document.cookie:', document.cookie)
    }

    const headers: HeadersInit = {
      'Cache-Control': 'no-cache', // Prevent caching of sensitive data
      'Pragma': 'no-cache',
      'ngrok-skip-browser-warning': 'true' // Skip ngrok browser warning
    }

    // Only add Authorization header if we have a valid token
    if (token && token.trim() && token !== 'undefined' && token !== 'null' && token.length > 10) {
      headers['Authorization'] = `Bearer ${token}`
      console.log('‚úÖ API Client: Authorization header added successfully')
      console.log('üîë API Client: Using auth token:', token.substring(0, 20) + '...')
    } else {
      console.warn('üö® API Client: No valid authentication token found - request will be sent without Authorization header')
      console.log('üç™ API Client: Available cookies:', document.cookie)
      console.log('üîç API Client: Token validation failed:')
      console.log('  - Token exists:', !!token)
      console.log('  - Token trimmed:', !!token?.trim())
      console.log('  - Not undefined string:', token !== 'undefined')
      console.log('  - Not null string:', token !== 'null')
      console.log('  - Length > 10:', (token?.length || 0) > 10)
    }

    return headers
  }

  /**
   * Enhanced API call wrapper with automatic token validation and retry logic
   */
  private async makeAuthenticatedRequest(
    url: string, 
    options: RequestInit = {}
  ): Promise<Response> {
    const maxRetries = 3 // Increased retries for vault page reliability
    let lastError: Error | null = null

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîê API Client: Making authenticated request (attempt ${attempt}/${maxRetries}) to:`, url)
        
        // Get fresh auth headers for each attempt
        const authHeaders = this.getAuthHeaders()
        
        // Check if we have a token
        const hasToken = (authHeaders as Record<string, string>)['Authorization']
        if (!hasToken) {
          // ENHANCED: More graceful handling for missing tokens
          console.warn('‚ö†Ô∏è API Client: No authentication token available')
          
          // For vault page, try to continue without token for some endpoints
          if (url.includes('/health') || url.includes('/conversations')) {
            console.log('üîÑ API Client: Attempting request without token for public endpoint')
            // Continue without auth headers
          } else {
            throw new Error('No authentication token available - please log in again')
          }
        } else {
          console.log('üîë API Client: Using token:', hasToken.substring(0, 20) + '...')
        }

        const response = await fetch(url, {
          ...options,
          headers: {
            ...authHeaders,
            ...options.headers
          },
          // ENHANCED: Longer timeout for vault page loading
          signal: AbortSignal.timeout(45000) // 45 second timeout for complex operations
        })

        console.log(`üìä API Client: Response status: ${response.status} (attempt ${attempt})`)

        // ENHANCED: Better 401 handling with retry logic
        if (response.status === 401) {
          console.warn(`üö® API Client: Received 401 Unauthorized on attempt ${attempt}`)
          
          // On first 401, try to refresh token if possible
          if (attempt === 1) {
            console.log('üîÑ API Client: First 401 - attempting token refresh')
            
            // Try to get a fresh token using the same fixed parsing logic
            let currentToken: string | undefined
            try {
              const cookies = document.cookie.split(';').map(cookie => cookie.trim())
              const authCookie = cookies.find(cookie => cookie.startsWith('auth-token='))
              
              if (authCookie) {
                const parts = authCookie.split('=')
                if (parts.length >= 2) {
                  const tokenValue = parts.slice(1).join('=')
                  if (tokenValue && tokenValue !== 'undefined' && tokenValue !== 'null' && tokenValue.trim() !== '') {
                    try {
                      currentToken = decodeURIComponent(tokenValue)
                      if (currentToken === 'undefined' || currentToken === 'null' || currentToken.trim() === '') {
                        currentToken = undefined
                      }
                    } catch (decodeError) {
                      currentToken = tokenValue
                    }
                  }
                }
              }
            } catch (error) {
              console.error('üö® API Client: Error parsing token for retry:', error)
            }
            
            if (currentToken) {
              console.log('üîÑ API Client: Token still exists, retrying request')
              // Continue to retry logic
              if (attempt < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, 1000))
                continue
              }
            }
          }
          
          // After retries or no token, clear and redirect
          console.warn('üö® API Client: Final 401 - clearing token and redirecting')
          document.cookie = 'auth-token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
          
          // Don't redirect immediately for vault page - let it handle gracefully
          if (url.includes('/vault') || url.includes('/documents') || url.includes('/curations')) {
            console.log('‚ö†Ô∏è API Client: Vault page 401 - allowing graceful degradation')
            return response // Return the 401 response for vault page to handle
          }
          
          throw new Error('Authentication expired - redirecting to login')
        }

        // ENHANCED: Handle other error codes more gracefully
        if (response.status >= 500) {
          console.error(`üö® API Client: Server error ${response.status} on attempt ${attempt}`)
          if (attempt < maxRetries) {
            // Retry server errors with exponential backoff
            const delay = Math.pow(2, attempt) * 1000
            console.log(`‚è≥ API Client: Retrying server error in ${delay}ms...`)
            await new Promise(resolve => setTimeout(resolve, delay))
            continue
          }
        }

        // Return the response for successful calls or client errors (4xx except 401)
        return response

      } catch (error) {
        lastError = error as Error
        console.error(`‚ùå API Client: Attempt ${attempt} failed:`, error)
        
        // ENHANCED: More intelligent retry logic
        if (error instanceof Error) {
          // Don't retry these critical errors
          if (error.message.includes('Authentication expired') || 
              error.message.includes('No authentication token')) {
            throw error
          }
          
          // Retry network errors and timeouts
          if (error.message.includes('Failed to fetch') ||
              error.message.includes('Network request failed') ||
              error.message.includes('timeout') ||
              error.name === 'TimeoutError' ||
              error.name === 'AbortError') {
            
            if (attempt < maxRetries) {
              const delay = Math.pow(2, attempt) * 1000
              console.log(`‚è≥ API Client: Retrying network error in ${delay}ms...`)
              await new Promise(resolve => setTimeout(resolve, delay))
              continue
            }
          }
        }
        
        // If we've exhausted retries, throw the error
        if (attempt >= maxRetries) {
          throw error
        }
        
        // Wait before retrying other errors
        const delay = Math.pow(2, attempt) * 1000
        console.log(`‚è≥ API Client: Waiting ${delay}ms before retry...`)
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }

    throw lastError || new Error('All retry attempts failed')
  }

  /**
   * Upload files to RAG backend - Enhanced with Sequential Processing Support
   */
  async uploadFiles(files: File[], options: { useBulkProcessing?: boolean, sequential?: boolean } = {}): Promise<UploadResponse> {
    const { useBulkProcessing = false, sequential = false } = options
    const formData = new FormData()
    
    files.forEach(file => {
      formData.append('files', file)
    })

    // Use bulk endpoint if multiple files or explicitly requested
    const endpoint = (files.length > 1 || useBulkProcessing) ? '/upload/bulk' : '/upload'
    const url = new URL(`${this.baseUrl}${endpoint}`)
    
    // Add sequential parameter if specified
    if (sequential && endpoint === '/upload') {
      url.searchParams.set('sequential', 'true')
    }

    // Enhanced logging for debugging
    const debugMode = process.env.NEXT_PUBLIC_DEBUG_MODE === 'true'
    if (debugMode) {
      console.log('=== API CLIENT UPLOAD DEBUG ===')
      console.log('Provider:', this.provider)
      console.log('Default Model:', process.env.NEXT_PUBLIC_DEFAULT_ANALYSIS_MODEL || 'Auto-detected')
      console.log('Processing Strategy:', files.length >= this.bulkUploadThreshold ? 'Bulk Processing' : 'Standard Processing')
      console.log('Endpoint:', endpoint)
      console.log('Final URL:', url)
      console.log('Files being uploaded:', files.map(f => f.name))
      console.log('Max file size:', this.maxFileSize, 'bytes')
      console.log('=== END API CLIENT DEBUG ===')
    }

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: formData
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Upload failed: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('Upload error:', error)
      throw error
    }
  }

  /**
   * Query documents using RAG
   */
  async queryDocuments(
    question: string, 
    options: {
      hybrid?: boolean
      maxContext?: boolean
      documentIds?: string[]
      provider?: string
      model?: string
    } = {}
  ): Promise<QueryResponse> {
    const { hybrid = this.hybrid, maxContext = false, documentIds, provider = 'gemini', model } = options
    
    const url = new URL(`${this.baseUrl}/query`)
    url.searchParams.set('hybrid', hybrid.toString())
    url.searchParams.set('max_context', maxContext.toString())

    console.log('=== API CLIENT QUERY DEBUG (MULTI-PROVIDER) ===')
    console.log('Provider:', provider)
    console.log('Model:', model)
    console.log('Hybrid:', hybrid)
    console.log('Max Context:', maxContext)
    console.log('Document IDs:', documentIds)
    console.log('Final URL:', url.toString())
    console.log('=== END API CLIENT DEBUG ===')

    try {
      const response = await fetch(url.toString(), {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          question,
          document_ids: documentIds,
          provider: provider,
          model: model
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Query failed: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('Query error:', error)
      throw error
    }
  }

  /**
   * Connect to WebSocket for progress updates with enhanced reliability
   */
  connectWebSocket(batchId: string): WebSocket {
    // Get token from cookie using the same fixed parsing logic
    let token: string | undefined
    
    try {
      const cookies = document.cookie.split(';').map(cookie => cookie.trim())
      const authCookie = cookies.find(cookie => cookie.startsWith('auth-token='))
      
      if (authCookie) {
        const parts = authCookie.split('=')
        if (parts.length >= 2) {
          const tokenValue = parts.slice(1).join('=')
          if (tokenValue && tokenValue !== 'undefined' && tokenValue !== 'null' && tokenValue.trim() !== '') {
            try {
              token = decodeURIComponent(tokenValue)
              if (token === 'undefined' || token === 'null' || token.trim() === '') {
                token = undefined
              }
            } catch (decodeError) {
              console.warn('üîß WebSocket: Token decode failed, using raw token:', decodeError)
              token = tokenValue
            }
          }
        }
      }
    } catch (error) {
      console.error('üö® WebSocket: Error reading auth token from cookies:', error)
    }

    const wsUrl = `${this.baseUrl.replace('http', 'ws')}/ws/${batchId}${token ? `?token=${token}` : ''}`
    const ws = new WebSocket(wsUrl)

    ws.onopen = () => {
      console.log(`WebSocket connected for batch: ${batchId}`)
    }

    ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }

    ws.onclose = (event) => {
      console.log(`WebSocket closed for batch: ${batchId}`, event.code, event.reason)
    }

    return ws
  }

  /**
   * Pre-establish WebSocket connection before upload
   */
  async preEstablishWebSocket(batchId: string): Promise<WebSocket> {
    return new Promise((resolve, reject) => {
      const ws = this.connectWebSocket(batchId)
      
      const timeout = setTimeout(() => {
        ws.close()
        reject(new Error('WebSocket connection timeout'))
      }, 10000) // 10 second timeout
      
      ws.onopen = () => {
        clearTimeout(timeout)
        console.log(`WebSocket pre-established for batch: ${batchId}`)
        resolve(ws)
      }
      
      ws.onerror = (error) => {
        clearTimeout(timeout)
        console.error('WebSocket pre-establishment failed:', error)
        reject(error)
      }
    })
  }

  /**
   * Enterprise-grade WebSocket with intelligent reconnection and message handling
   */
  createReliableWebSocket(batchId: string, onMessage: (data: any) => void): {
    ws: WebSocket | null,
    connect: () => Promise<void>,
    disconnect: () => void,
    isConnected: () => boolean,
    sendMessage: (message: any) => Promise<boolean>,
    getConnectionHealth: () => Promise<any>
  } {
    let ws: WebSocket | null = null
    let reconnectAttempts = 0
    const maxReconnectAttempts = parseInt(process.env.NEXT_PUBLIC_WS_RECONNECT_ATTEMPTS || '8')
    let isManuallyDisconnected = false
    let reconnectTimeout: NodeJS.Timeout | null = null
    let heartbeatInterval: NodeJS.Timeout | null = null
    let connectionStartTime = 0
    let lastMessageTime = 0
    let messageQueue: any[] = []

    const connect = async (): Promise<void> => {
      return new Promise((resolve, reject) => {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            resolve()
            return
          }

          connectionStartTime = Date.now()
          ws = this.connectWebSocket(batchId)
          
          const timeout = setTimeout(() => {
            if (ws) ws.close()
            reject(new Error('Enterprise WebSocket connection timeout'))
          }, 15000) // Increased timeout for enterprise reliability

          ws.onopen = () => {
            clearTimeout(timeout)
            reconnectAttempts = 0
            lastMessageTime = Date.now()
            
            console.log(`Enterprise WebSocket connected for batch: ${batchId}`)
            
            // Send client ready signal
            sendMessage({ type: 'client_ready', timestamp: Date.now() })
            
            // Start heartbeat monitoring
            startHeartbeat()
            
            // Flush any queued messages
            flushMessageQueue()
            
            resolve()
          }

          ws.onmessage = (event) => {
            try {
              lastMessageTime = Date.now()
              const data = JSON.parse(event.data)
              
              // Handle special message types
              if (data.type === 'heartbeat') {
                // Respond to server heartbeat
                sendMessage({ type: 'pong', timestamp: Date.now() })
                return
              }
              
              if (data.type === 'connection_status') {
                console.log('Connection status update:', data.data)
                // Don't pass connection status to main handler unless it's critical
                if (data.data?.status === 'established' || data.data?.status === 'error') {
                  onMessage(data)
                }
                return
              }
              
              if (data.type === 'flush_start') {
                console.log('Server starting message flush:', data.data)
                return
              }
              
              if (data.type === 'flush_complete') {
                console.log('Server completed message flush:', data.data)
                return
              }
              
              // Pass all other messages to the handler
              onMessage(data)
              
            } catch (error) {
              console.error('Failed to parse WebSocket message:', error)
            }
          }

          ws.onclose = (event) => {
            clearTimeout(timeout)
            stopHeartbeat()
            
            console.log(`Enterprise WebSocket closed for batch: ${batchId}`, event.code, event.reason)
            
            // Attempt intelligent reconnection
            if (!isManuallyDisconnected && reconnectAttempts < maxReconnectAttempts) {
              reconnectAttempts++
              
              // Exponential backoff with jitter
              const baseDelay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000)
              const jitter = Math.random() * 1000
              const delay = baseDelay + jitter
              
              console.log(`Attempting enterprise WebSocket reconnection ${reconnectAttempts}/${maxReconnectAttempts} in ${delay.toFixed(0)}ms`)
              
              reconnectTimeout = setTimeout(() => {
                connect().catch((error) => {
                  console.error('Reconnection failed:', error)
                  if (reconnectAttempts >= maxReconnectAttempts) {
                    console.error('Max reconnection attempts reached for batch:', batchId)
                    onMessage({
                      type: 'connection_failed',
                      data: {
                        message: 'Failed to establish reliable connection after multiple attempts',
                        batch_id: batchId,
                        attempts: reconnectAttempts
                      }
                    })
                  }
                })
              }, delay)
            }
          }

          ws.onerror = (error) => {
            clearTimeout(timeout)
            console.error('Enterprise WebSocket error:', error)
            reject(error)
          }

        } catch (error) {
          reject(error)
        }
      })
    }

    const sendMessage = async (message: any): Promise<boolean> => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify(message))
          return true
        } catch (error) {
          console.error('Failed to send WebSocket message:', error)
          messageQueue.push(message)
          return false
        }
      } else {
        // Queue message for later delivery
        messageQueue.push(message)
        return false
      }
    }

    const flushMessageQueue = () => {
      if (messageQueue.length > 0 && ws && ws.readyState === WebSocket.OPEN) {
        console.log(`Flushing ${messageQueue.length} queued client messages`)
        const messages = [...messageQueue]
        messageQueue = []
        
        messages.forEach(message => {
          try {
            ws!.send(JSON.stringify(message))
          } catch (error) {
            console.error('Failed to flush queued message:', error)
            messageQueue.push(message) // Re-queue failed message
          }
        })
      }
    }

    const startHeartbeat = () => {
      stopHeartbeat()
      heartbeatInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          sendMessage({ type: 'ping', timestamp: Date.now() })
          
          // Check for stale connection
          const timeSinceLastMessage = Date.now() - lastMessageTime
          if (timeSinceLastMessage > 60000) { // 1 minute without any message
            console.warn('WebSocket connection appears stale, requesting status')
            sendMessage({ type: 'request_status' })
          }
        }
      }, parseInt(process.env.NEXT_PUBLIC_WS_HEARTBEAT_INTERVAL || '20000'))
    }

    const stopHeartbeat = () => {
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval)
        heartbeatInterval = null
      }
    }

    const getConnectionHealth = async (): Promise<any> => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        await sendMessage({ type: 'request_health' })
        return {
          connected: true,
          uptime: Date.now() - connectionStartTime,
          lastMessage: Date.now() - lastMessageTime,
          reconnectAttempts,
          queuedMessages: messageQueue.length
        }
      }
      return {
        connected: false,
        uptime: 0,
        lastMessage: -1,
        reconnectAttempts,
        queuedMessages: messageQueue.length
      }
    }

    const disconnect = () => {
      isManuallyDisconnected = true
      stopHeartbeat()
      
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout)
        reconnectTimeout = null
      }
      
      if (ws) {
        ws.close(1000, 'Manual disconnect')
        ws = null
      }
      
      messageQueue = []
      console.log(`Enterprise WebSocket manually disconnected for batch: ${batchId}`)
    }

    const isConnected = () => {
      return ws !== null && ws.readyState === WebSocket.OPEN
    }

    return { 
      ws, 
      connect, 
      disconnect, 
      isConnected, 
      sendMessage, 
      getConnectionHealth 
    }
  }

  /**
   * Handle authentication errors with automatic redirect
   */
  private handleAuthError(error: Error): void {
    if (error.message.includes('Authentication failed') || 
        error.message.includes('Authorization header missing') ||
        error.message.includes('Invalid or expired token')) {
      console.warn('üö® API Client: Authentication error detected')
      
      // Clear any existing auth tokens
      document.cookie = 'auth-token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
      
      // Only redirect if we're not already on the login page and the error is actually a session expiration
      if (typeof window !== 'undefined' && 
          !window.location.pathname.includes('/login') &&
          error.message.includes('expired')) {
        console.warn('üö® API Client: Session expired, redirecting to login')
        // Use replace to avoid adding to browser history
        window.location.replace('/login?reason=session_expired')
      } else {
        console.warn('üö® API Client: Authentication error but not redirecting - may be initial load or other auth issue')
      }
    }
  }

  /**
   * Get user documents from backend - FIXED: No caching to prevent sync issues
   */
  async getUserDocuments(): Promise<BackendDocument[]> {
    console.log('üîÑ API Client: Fetching fresh documents from backend (no cache)')
    
    try {
      const result = await this.fetchDocumentsFromAPI()
      console.log(`‚úÖ API Client: Successfully fetched ${result.length} documents from backend`)
      return result
    } catch (error) {
      console.error('‚ùå API Client: Failed to fetch documents:', error)
      return []
    }
  }

  /**
   * Internal method to fetch documents from API
   */
  private async fetchDocumentsFromAPI(): Promise<BackendDocument[]> {
    const maxRetries = 3
    let lastError: Error | null = null

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`API Client: Fetching documents (attempt ${attempt}/${maxRetries}) from:`, `${this.baseUrl}/documents`)
        
        // Check if we have a valid token before making the request
        const authHeaders = this.getAuthHeaders()
        const hasValidToken = (authHeaders as Record<string, string>)['Authorization']
        
        if (!hasValidToken) {
          console.warn('API Client: No valid authentication token available for getUserDocuments')
          // Return empty array instead of throwing error to allow graceful degradation
          return []
        }
        
        const response = await fetch(`${this.baseUrl}/documents`, {
          headers: {
            ...authHeaders,
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        })

        console.log(`API Client: Response status: ${response.status} (attempt ${attempt})`)

        if (!response.ok) {
          if (response.status === 401) {
            console.warn('API Client: Received 401 Unauthorized for getUserDocuments')
            // Clear the invalid token
            if (typeof document !== 'undefined') {
              document.cookie = 'auth-token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
            }
            // Return empty array instead of throwing error to allow graceful degradation
            return []
          }
          if (response.status === 404) {
            console.log('API Client: Documents endpoint not found, returning empty array')
            return []
          }
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        // Check if response has content
        const contentType = response.headers.get('content-type')
        if (!contentType || !contentType.includes('application/json')) {
          console.warn('API Client: Response is not JSON, returning empty array')
          return []
        }

        const text = await response.text()
        if (!text.trim()) {
          console.warn('API Client: Empty response body, returning empty array')
          return []
        }

        try {
          const data = JSON.parse(text)
          console.log(`API Client: Successfully parsed ${data.length || 0} documents (attempt ${attempt})`)
          return Array.isArray(data) ? data : []
        } catch (parseError) {
          console.error('API Client: JSON parse error:', parseError)
          console.error('API Client: Response text length:', text.length)
          console.error('API Client: Response text preview:', text.substring(0, 200) + '...')
          
          // Check if this is the specific "Unterminated string" error
          if (parseError instanceof SyntaxError && parseError.message.includes('Unterminated string')) {
            console.error('API Client: Detected unterminated string error - likely large response truncation')
            
            // Try to salvage partial JSON by finding the last complete object
            try {
              const lastCompleteIndex = text.lastIndexOf('"}]')
              if (lastCompleteIndex > 0) {
                const truncatedText = text.substring(0, lastCompleteIndex + 3)
                console.log('API Client: Attempting to parse truncated response...')
                const salvaged = JSON.parse(truncatedText)
                console.log(`API Client: Successfully salvaged ${salvaged.length || 0} documents from truncated response`)
                return Array.isArray(salvaged) ? salvaged : []
              }
            } catch (salvageError) {
              console.error('API Client: Failed to salvage truncated response:', salvageError)
            }
          }
          
          return []
        }

      } catch (error) {
        lastError = error as Error
        console.error(`API Client: Attempt ${attempt} failed:`, error)
        
        // For authentication errors, return empty array instead of throwing
        if (error instanceof Error && error.message.includes('Authentication failed')) {
          console.warn('API Client: Authentication failed, returning empty documents array')
          return []
        }
        
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000 // Exponential backoff: 2s, 4s, 8s
          console.log(`API Client: Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
        }
      }
    }

    console.error('API Client: All retry attempts failed:', lastError)
    // Return empty array instead of throwing error to allow graceful degradation
    console.warn('API Client: Returning empty documents array due to persistent failures')
    return []
  }

  /**
   * Delete a document and all associated data
   */
  async deleteDocument(documentId: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/documents/${documentId}`, {
        method: 'DELETE',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Delete failed: ${response.status}`)
      }

      const result = await response.json()
      console.log('Document deletion result:', result)
      return true
    } catch (error) {
      console.error('Delete document error:', error)
      throw error
    }
  }

  /**
   * Health check
   */
  async healthCheck(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/health`, {
        method: 'GET'
      })
      return response.ok
    } catch (error) {
      console.error('Health check failed:', error)
      return false
    }
  }

  /**
   * Get available providers
   */
  getAvailableProviders(): string[] {
    return ['openai', 'groq', 'anthropic', 'local']
  }

  /**
   * Get available models - Enhanced Multi-Provider Support with Better Error Handling and CACHING
   */
  async getAvailableModels(): Promise<ModelProvider[]> {
    console.log('üîç API Client: Starting getAvailableModels() - Enhanced Multi-Provider Mode with Caching')
    console.log('üåê API Client: Base URL:', this.baseUrl)
    
    // Check cache first
    const currentTime = Date.now()
    if (this.providersCache && 
        this.providersCacheTimestamp && 
        (currentTime - this.providersCacheTimestamp) < this.PROVIDERS_CACHE_DURATION) {
      
      console.log(`üöÄ API CLIENT CACHE HIT: Returning cached providers (age: ${(currentTime - this.providersCacheTimestamp) / 1000}s)`)
      return this.providersCache
    }
    
    // If there's already a request in progress, wait for it
    if (this.providersCachePromise) {
      console.log('üîÑ API CLIENT: Providers request already in progress, waiting for result...')
      return this.providersCachePromise
    }
    
    console.log('üîÑ API CLIENT CACHE MISS: Fetching fresh providers data')
    
    // Create a new promise for this request
    this.providersCachePromise = this.fetchProvidersFromAPI()
    
    try {
      const result = await this.providersCachePromise
      
      // Cache the result
      this.providersCache = result
      this.providersCacheTimestamp = currentTime
      
      console.log(`‚úÖ API CLIENT: Cached ${result.length} providers for ${this.PROVIDERS_CACHE_DURATION / 1000}s`)
      
      return result
    } finally {
      // Clear the promise so future calls can make new requests
      this.providersCachePromise = null
    }
  }

  /**
   * Internal method to fetch providers from API
   */
  private async fetchProvidersFromAPI(): Promise<ModelProvider[]> {
    try {
      // Enhanced request with better headers and error handling
      console.log('üöÄ API Client: Attempting to fetch all providers from:', `${this.baseUrl}/providers/all`)
      
      const response = await fetch(`${this.baseUrl}/providers/all`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache',
          'ngrok-skip-browser-warning': 'true'
        },
        mode: 'cors',
        credentials: 'include'
      })
      
      console.log('üìä API Client: All providers response status:', response.status)
      console.log('üìã API Client: Response headers:', Object.fromEntries(response.headers.entries()))
      
      if (response.ok) {
        const responseText = await response.text()
        console.log('üìù API Client: Raw response text length:', responseText.length)
        
        if (!responseText.trim()) {
          console.warn('‚ö†Ô∏è API Client: Empty response body from all-providers endpoint')
          throw new Error('Empty response from server')
        }
        
        let data
        try {
          data = JSON.parse(responseText)
          console.log('‚úÖ API Client: All providers data parsed successfully:', data)
        } catch (parseError) {
          console.error('‚ùå API Client: JSON parse error:', parseError)
          console.error('üìÑ API Client: Response text preview:', responseText.substring(0, 500))
          throw new Error(`Invalid JSON response: ${parseError}`)
        }
        
        if (data.providers && Array.isArray(data.providers) && data.providers.length > 0) {
          const providers: ModelProvider[] = data.providers
            .filter((provider: any) => provider.can_execute && provider.enabled) // Only include working providers
            .map((provider: any) => ({
              name: provider.name,
              displayName: provider.display_name || provider.name.charAt(0).toUpperCase() + provider.name.slice(1),
              isAvailable: provider.can_execute && provider.enabled,
              models: (provider.models || []).map((modelName: string) => ({
                name: modelName,
                provider: provider.name,
                displayName: this.getModelDisplayName(provider.name, modelName),
                description: this.getModelDescription(provider.name, modelName),
                isAvailable: true,
                isLocal: provider.name === 'ollama' || provider.name === 'local'
              }))
            }))
          
          console.log('üéâ API Client: Successfully loaded', providers.length, 'providers with models:')
          providers.forEach(p => console.log(`   - ${p.displayName}: ${p.models.length} models (available: ${p.isAvailable})`))
          return providers
        } else {
          console.warn('‚ö†Ô∏è API Client: No valid providers in response:', data)
        }
      } else {
        const errorText = await response.text().catch(() => 'Unable to read error response')
        console.error('‚ùå API Client: All providers endpoint failed:', response.status, response.statusText)
        console.error('üìÑ API Client: Error response:', errorText)
        
        if (response.status === 401) {
          throw new Error('Authentication failed - please log in again')
        } else if (response.status === 404) {
          console.log('üìç API Client: All providers endpoint not found, using fallback strategy')
        } else {
          throw new Error(`HTTP ${response.status}: ${errorText}`)
        }
      }
      
      console.log('üîÑ API Client: All providers endpoint failed, falling back to individual provider fetching')
    } catch (error) {
      console.error('‚ùå API Client: Failed to fetch all providers:', error)
      console.log('üîÑ API Client: Proceeding with fallback strategy')
    }
    
    // Enhanced fallback strategy - try to build providers manually
    const providers: ModelProvider[] = []

    // Skip Ollama provider - removed from frontend

    // Add other providers based on environment configuration
    console.log('üîë API Client: Adding cloud providers based on environment configuration...')
    
    const availableProviders = (process.env.NEXT_PUBLIC_AVAILABLE_PROVIDERS || '').split(',').map(p => p.trim())
    
    // OpenAI Provider
    if (availableProviders.includes('openai')) {
      const openaiModels = (process.env.NEXT_PUBLIC_OPENAI_MODELS || 'gpt-4o-mini,gpt-3.5-turbo,gpt-4').split(',').map(m => m.trim())
      providers.push({
        name: 'openai',
        displayName: 'OpenAI',
        isAvailable: true,
        models: openaiModels.map(model => ({
          name: model,
          provider: 'openai',
          displayName: model.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          description: this.getModelDescription('openai', model),
          isAvailable: true,
          isLocal: false
        }))
      })
    }

    // Groq Provider
    if (availableProviders.includes('groq')) {
      const groqModels = (process.env.NEXT_PUBLIC_GROQ_MODELS || 'llama3-8b-8192,mixtral-8x7b-32768').split(',').map(m => m.trim())
      providers.push({
        name: 'groq',
        displayName: 'Groq',
        isAvailable: true,
        models: groqModels.map(model => ({
          name: model,
          provider: 'groq',
          displayName: model.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          description: this.getModelDescription('groq', model),
          isAvailable: true,
          isLocal: false
        }))
      })
    }

    // Gemini Provider
    if (availableProviders.includes('gemini')) {
      const geminiModels = (process.env.NEXT_PUBLIC_GEMINI_MODELS || 'gemini-1.5-flash,gemini-1.5-pro').split(',').map(m => m.trim())
      providers.push({
        name: 'gemini',
        displayName: 'Google Gemini',
        isAvailable: true,
        models: geminiModels.map(model => ({
          name: model,
          provider: 'gemini',
          displayName: model.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          description: this.getModelDescription('gemini', model),
          isAvailable: true,
          isLocal: false
        }))
      })
    }

    // DeepSeek Provider
    if (availableProviders.includes('deepseek')) {
      const deepseekModels = (process.env.NEXT_PUBLIC_DEEPSEEK_MODELS || 'deepseek-chat,deepseek-coder').split(',').map(m => m.trim())
      providers.push({
        name: 'deepseek',
        displayName: 'DeepSeek',
        isAvailable: true,
        models: deepseekModels.map(model => ({
          name: model,
          provider: 'deepseek',
          displayName: model.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          description: this.getModelDescription('deepseek', model),
          isAvailable: true,
          isLocal: false
        }))
      })
    }

    // AWS Bedrock Provider
    if (availableProviders.includes('bedrock')) {
      const bedrockModels = (process.env.NEXT_PUBLIC_BEDROCK_MODELS || 'anthropic.claude-3-haiku-20240307-v1:0').split(',').map(m => m.trim())
      providers.push({
        name: 'bedrock',
        displayName: 'AWS Bedrock',
        isAvailable: true,
        models: bedrockModels.map(model => ({
          name: model,
          provider: 'bedrock',
          displayName: this.getBedrockDisplayName(model),
          description: this.getModelDescription('bedrock', model),
          isAvailable: true,
          isLocal: false
        }))
      })
    }

    console.log('üéâ API Client: Final providers summary:')
    console.log(`   Total providers: ${providers.length}`)
    providers.forEach(p => {
      console.log(`   - ${p.displayName}: ${p.models.length} models (${p.isAvailable ? 'Available' : 'Unavailable'})`)
    })
    
    return providers
  }

  /**
   * Get models for a specific provider
   */
  async getProviderModels(providerName: string): Promise<AvailableModel[]> {
    const providers = await this.getAvailableModels()
    const provider = providers.find(p => p.name === providerName)
    return provider?.models || []
  }

  /**
   * AI Curation API Methods
   */

  /**
   * Get user's AI curations
   */
  async getAICurations(): Promise<AICuration[]> {
    try {
      console.log('üîç API Client: Fetching AI curations from:', `${this.baseUrl}/curations`)
      console.log('üîê API Client: Using auth headers:', this.getAuthHeaders())
      
      const response = await fetch(`${this.baseUrl}/curations`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      console.log('üìä API Client: Curations response status:', response.status)
      console.log('üìã API Client: Response headers:', Object.fromEntries(response.headers.entries()))

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unable to read error response')
        console.error('‚ùå API Client: Curations endpoint failed:', response.status, response.statusText)
        console.error('üìÑ API Client: Error response body:', errorText)
        
        if (response.status === 401) {
          const authError = new Error('Authentication failed - please log in again')
          this.handleAuthError(authError)
          throw authError
        }
        if (response.status === 404) {
          console.log('üìç API Client: Curations endpoint not found, returning empty array')
          return []
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`)
      }

      const responseText = await response.text()
      console.log('üìù API Client: Raw curations response length:', responseText.length)
      
      if (!responseText.trim()) {
        console.warn('‚ö†Ô∏è API Client: Empty curations response body')
        return []
      }

      let data
      try {
        data = JSON.parse(responseText)
        console.log('‚úÖ API Client: Successfully parsed curations data:', data)
      } catch (parseError) {
        console.error('‚ùå API Client: Failed to parse curations JSON:', parseError)
        console.error('üìÑ API Client: Response text preview:', responseText.substring(0, 500))
        return []
      }

      const curations = Array.isArray(data) ? data : []
      console.log('üéâ API Client: Successfully fetched', curations.length, 'AI curations')
      
      // Log details of each curation for debugging
      curations.forEach((curation, index) => {
        console.log(`üìÑ Curation ${index + 1}:`, {
          id: curation.id,
          title: curation.title,
          status: curation.status,
          autoGenerated: curation.autoGenerated
        })
      })
      
      return curations
    } catch (error) {
      console.error('üí• API Client: Failed to fetch AI curations:', error)
      console.error('üîó API Client: Base URL being used:', this.baseUrl)
      console.error('üç™ API Client: Available cookies:', document.cookie)
      return []
    }
  }

  /**
   * Generate/regenerate AI curations
   */
  async generateAICurations(options: {
    provider?: string
    model?: string
    forceRegenerate?: boolean
  } = {}): Promise<{ success: boolean; message: string; curations?: AICuration[] }> {
    try {
      console.log('API Client: Generating AI curations with options:', options)
      
      const response = await fetch(`${this.baseUrl}/curations/generate`, {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({
          provider: options.provider,
          model: options.model,
          force_regenerate: options.forceRegenerate || false
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Generation failed: ${response.status}`)
      }

      const result = await response.json()
      console.log('API Client: AI curation generation result:', result)
      return result
    } catch (error) {
      console.error('API Client: Failed to generate AI curations:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * Get AI curation settings
   */
  async getCurationSettings(): Promise<CurationSettings> {
    try {
      const response = await fetch(`${this.baseUrl}/curations/settings`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        if (response.status === 404) {
          // Return default settings if not found
          return {
            autoRefresh: true,
            onAdd: 'incremental',
            onDelete: 'auto_clean',
            changeThreshold: 15,
            maxCurations: 10,
            minDocumentsPerCuration: 2
          }
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to fetch curation settings:', error)
      // Return default settings on error
      return {
        autoRefresh: true,
        onAdd: 'incremental',
        onDelete: 'auto_clean',
        changeThreshold: 15,
        maxCurations: 10,
        minDocumentsPerCuration: 2
      }
    }
  }

  /**
   * Update AI curation settings
   */
  async updateCurationSettings(settings: Partial<CurationSettings>): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/curations/settings`, {
        method: 'PUT',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify(settings)
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Update failed: ${response.status}`)
      }

      console.log('API Client: Successfully updated curation settings')
      return true
    } catch (error) {
      console.error('API Client: Failed to update curation settings:', error)
      return false
    }
  }

  /**
   * Get AI curation system status
   */
  async getCurationStatus(): Promise<CurationStatus> {
    try {
      const response = await fetch(`${this.baseUrl}/curations/status`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        if (response.status === 404) {
          // Return default status if not found
          return {
            totalCurations: 0,
            freshCurations: 0,
            staleCurations: 0,
            lastGenerated: null,
            documentsAnalyzed: 0
          }
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to fetch curation status:', error)
      // Return default status on error
      return {
        totalCurations: 0,
        freshCurations: 0,
        staleCurations: 0,
        lastGenerated: null,
        documentsAnalyzed: 0
      }
    }
  }

  /**
   * Refresh a specific AI curation
   */
  async refreshCuration(curationId: string, options: {
    provider?: string
    model?: string
  } = {}): Promise<{ success: boolean; message: string; curation?: AICuration }> {
    try {
      const response = await fetch(`${this.baseUrl}/curations/${curationId}/refresh`, {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({
          provider: options.provider,
          model: options.model
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Refresh failed: ${response.status}`)
      }

      const result = await response.json()
      console.log('API Client: Curation refresh result:', result)
      return result
    } catch (error) {
      console.error('API Client: Failed to refresh curation:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * Get curation content (stored content if exists, generates if not)
   */
  async getCurationContent(
    curationId: string,
    provider: string = "gemini",
    model: string = "gemini-1.5-flash"
  ): Promise<{ success: boolean; content?: string; message: string; cached?: boolean }> {
    try {
      console.log('üîç API Client: Getting curation content for:', curationId, 'with provider:', provider, 'model:', model)
      
      const response = await this.makeAuthenticatedRequest(
        `${this.baseUrl}/curations/${curationId}/content?provider=${provider}&model=${model}`,
        {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'ngrok-skip-browser-warning': 'true'
          }
        }
      )

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        console.error('‚ùå API Client: Curation content request failed:', response.status, errorData)
        throw new Error(errorData.detail || `Failed to get curation content: ${response.status}`)
      }

      const result = await response.json()
      console.log('‚úÖ API Client: Curation content result:', {
        success: result.success,
        cached: result.cached,
        contentLength: result.content?.length || 0,
        message: result.message
      })
      return result
    } catch (error) {
      console.error('üí• API Client: Failed to get curation content:', error)
      
      // Handle authentication errors specifically
      if (error instanceof Error && error.message.includes('Authentication expired')) {
        return {
          success: false,
          message: 'Your session has expired. Please refresh the page to log in again.',
          cached: false
        }
      }
      
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred',
        cached: false
      }
    }
  }

  /**
   * Delete a curation
   */
  async deleteCuration(curationId: string): Promise<{ success: boolean; message: string }> {
    try {
      console.log('API Client: Deleting curation:', curationId)
      
      const response = await fetch(`${this.baseUrl}/curations/${curationId}`, {
        method: 'DELETE',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to delete curation: ${response.status}`)
      }

      const result = await response.json()
      console.log('API Client: Curation deletion result:', result)
      return {
        success: true,
        message: result.message || 'Curation deleted successfully'
      }
    } catch (error) {
      console.error('API Client: Failed to delete curation:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * Delete a summary
   */
  async deleteSummary(summaryId: string): Promise<{ success: boolean; message: string }> {
    try {
      console.log('API Client: Deleting summary:', summaryId)
      
      const response = await fetch(`${this.baseUrl}/summaries/${summaryId}`, {
        method: 'DELETE',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to delete summary: ${response.status}`)
      }

      const result = await response.json()
      console.log('API Client: Summary deletion result:', result)
      return {
        success: true,
        message: result.message || 'Summary deleted successfully'
      }
    } catch (error) {
      console.error('API Client: Failed to delete summary:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * Create a custom AI curation with user-defined topic and keywords
   */
  async createCustomCuration(options: {
    title: string
    description?: string
    keywords: string[]
    provider: string
    model: string
  }): Promise<{ success: boolean; message: string; curation?: AICuration }> {
    try {
      console.log('API Client: Creating custom curation:', options.title)
      
      const response = await fetch(`${this.baseUrl}/curations/custom`, {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({
          title: options.title,
          description: options.description,
          keywords: options.keywords,
          provider: options.provider,
          model: options.model
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Custom curation creation failed: ${response.status}`)
      }

      const result = await response.json()
      console.log('API Client: Custom curation creation result:', result)
      return {
        success: true,
        message: 'Custom curation created successfully',
        curation: result
      }
    } catch (error) {
      console.error('API Client: Failed to create custom curation:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * Get display name for models
   */
  private getModelDisplayName(provider: string, model: string): string {
    const displayNames: Record<string, Record<string, string>> = {
      openai: {
        'gpt-4o-mini': 'GPT-4o Mini',
        'gpt-3.5-turbo': 'GPT-3.5 Turbo',
        'gpt-4': 'GPT-4'
      },
      groq: {
        'llama3-8b-8192': 'Llama 3 8B',
        'mixtral-8x7b-32768': 'Mixtral 8x7B'
      },
      gemini: {
        'gemini-1.5-flash': 'Gemini 1.5 Flash',
        'gemini-1.5-pro': 'Gemini 1.5 Pro'
      },
      deepseek: {
        'deepseek-chat': 'DeepSeek Chat',
        'deepseek-coder': 'DeepSeek Coder'
      },
      bedrock: {
        'anthropic.claude-3-haiku-20240307-v1:0': 'Claude 3 Haiku',
        'anthropic.claude-3-sonnet-20240229-v1:0': 'Claude 3 Sonnet'
      }
    }

    return displayNames[provider]?.[model] || model.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
  }

  /**
   * Get model description based on provider and model name
   */
  private getModelDescription(provider: string, model: string): string {
    const descriptions: Record<string, Record<string, string>> = {
      openai: {
        'gpt-4o-mini': 'Fast and cost-effective GPT-4 model',
        'gpt-3.5-turbo': 'Fast and reliable ChatGPT model',
        'gpt-4': 'Most capable OpenAI model'
      },
      groq: {
        'llama3-8b-8192': 'Ultra-fast Llama 3 with 8K context',
        'mixtral-8x7b-32768': 'High-performance mixture of experts'
      },
      gemini: {
        'gemini-1.5-flash': 'Fast and efficient Gemini model',
        'gemini-1.5-pro': 'Most capable Gemini model'
      },
      deepseek: {
        'deepseek-chat': 'Cost-effective high-performance chat model',
        'deepseek-coder': 'Specialized coding model'
      },
      bedrock: {
        'anthropic.claude-3-haiku-20240307-v1:0': 'Fast and efficient Claude 3 Haiku model',
        'anthropic.claude-3-sonnet-20240229-v1:0': 'Balanced Claude 3 Sonnet model'
      }
    }

    return descriptions[provider]?.[model] || `AI model for ${provider}`
  }

  /**
   * Get display name for Bedrock models
   */
  private getBedrockDisplayName(model: string): string {
    const bedrockNames: Record<string, string> = {
      'anthropic.claude-3-haiku-20240307-v1:0': 'Claude 3 Haiku',
      'anthropic.claude-3-sonnet-20240229-v1:0': 'Claude 3 Sonnet',
      'anthropic.claude-3-opus-20240229-v1:0': 'Claude 3 Opus'
    }

    return bedrockNames[model] || model.split('.')[1]?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || model
  }

  /**
   * Conversation Management API Methods
   */

  /**
   * Get user's conversations
   */
  async getConversations(options: {
    includeArchived?: boolean
    limit?: number
    offset?: number
    search?: string
  } = {}): Promise<Conversation[]> {
    try {
      console.log('üîç API Client: Fetching conversations from:', `${this.baseUrl}/conversations`)
      console.log('üîê API Client: Using auth headers:', this.getAuthHeaders())
      
      const params = new URLSearchParams()
      if (options.includeArchived) params.set('include_archived', 'true')
      if (options.limit) params.set('limit', options.limit.toString())
      if (options.offset) params.set('offset', options.offset.toString())
      if (options.search) params.set('search', options.search)

      const response = await fetch(`${this.baseUrl}/conversations?${params}`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      console.log('üìä API Client: Conversations response status:', response.status)
      console.log('üìã API Client: Response headers:', Object.fromEntries(response.headers.entries()))

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unable to read error response')
        console.error('‚ùå API Client: Conversations endpoint failed:', response.status, response.statusText)
        console.error('üìÑ API Client: Error response body:', errorText)
        
        if (response.status === 401) {
          throw new Error('Authentication failed - please log in again')
        }
        if (response.status === 404) {
          console.log('üìç API Client: Conversations endpoint not found, returning empty array')
          return []
        }
        
        let errorData
        try {
          errorData = JSON.parse(errorText)
        } catch {
          errorData = { detail: errorText }
        }
        
        throw new Error(errorData.detail || `Failed to fetch conversations: ${response.status}`)
      }

      const responseText = await response.text()
      console.log('üìù API Client: Raw conversations response length:', responseText.length)
      
      if (!responseText.trim()) {
        console.warn('‚ö†Ô∏è API Client: Empty conversations response body')
        return []
      }

      let data
      try {
        data = JSON.parse(responseText)
        console.log('‚úÖ API Client: Successfully parsed conversations data:', data)
      } catch (parseError) {
        console.error('‚ùå API Client: Failed to parse conversations JSON:', parseError)
        console.error('üìÑ API Client: Response text preview:', responseText.substring(0, 500))
        return []
      }

      const conversations = Array.isArray(data) ? data : []
      console.log('üéâ API Client: Successfully fetched', conversations.length, 'conversations')
      
      return conversations
    } catch (error) {
      console.error('üí• API Client: Failed to fetch conversations:', error)
      console.error('üîó API Client: Base URL being used:', this.baseUrl)
      console.error('üç™ API Client: Available cookies:', document.cookie)
      return []
    }
  }

  /**
   * Get a specific conversation with messages
   */
  async getConversation(
    conversationId: string,
    options: {
      messageLimit?: number
      messageOffset?: number
    } = {}
  ): Promise<ConversationWithMessages | null> {
    try {
      const params = new URLSearchParams()
      if (options.messageLimit) params.set('message_limit', options.messageLimit.toString())
      if (options.messageOffset) params.set('message_offset', options.messageOffset.toString())

      const response = await fetch(`${this.baseUrl}/conversations/${conversationId}?${params}`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        if (response.status === 404) return null
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to fetch conversation: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to fetch conversation:', error)
      return null
    }
  }

  /**
   * Create a new conversation
   */
  async createConversation(options: {
    title?: string
    autoGenerateTitle?: boolean
  } = {}): Promise<Conversation | null> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations`, {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({
          title: options.title,
          auto_generate_title: options.autoGenerateTitle ?? true
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to create conversation: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to create conversation:', error)
      return null
    }
  }

  /**
   * Update conversation properties
   */
  async updateConversation(
    conversationId: string,
    updates: {
      title?: string
      isArchived?: boolean
      isPinned?: boolean
      tags?: string[]
    }
  ): Promise<Conversation | null> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/${conversationId}`, {
        method: 'PUT',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({
          title: updates.title,
          is_archived: updates.isArchived,
          is_pinned: updates.isPinned,
          tags: updates.tags
        })
      })

      if (!response.ok) {
        if (response.status === 404) return null
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to update conversation: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to update conversation:', error)
      return null
    }
  }

  /**
   * Delete a conversation
   */
  async deleteConversation(conversationId: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/${conversationId}`, {
        method: 'DELETE',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        if (response.status === 404) return false
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to delete conversation: ${response.status}`)
      }

      return true
    } catch (error) {
      console.error('API Client: Failed to delete conversation:', error)
      return false
    }
  }

  /**
   * Add a message to a conversation
   */
  async addMessage(
    conversationId: string,
    message: {
      role: string
      content: string
      providerUsed?: string
      modelUsed?: string
      documentIds?: string[]
      sources?: Array<{ document: string; text: string; score: number }>
      contextMode?: string
      metadata?: Record<string, any>
      tokensUsed?: number
      responseTimeMs?: number
      curationId?: string
      summaryId?: string
    }
  ): Promise<Message | null> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/${conversationId}/messages`, {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({
          role: message.role,
          content: message.content,
          provider_used: message.providerUsed,
          model_used: message.modelUsed,
          document_ids: message.documentIds,
          sources: message.sources,
          context_mode: message.contextMode,
          metadata: message.metadata,
          tokens_used: message.tokensUsed,
          response_time_ms: message.responseTimeMs,
          curation_id: message.curationId,
          summary_id: message.summaryId
        })
      })

      if (!response.ok) {
        if (response.status === 404) return null
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to add message: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to add message:', error)
      return null
    }
  }

  /**
   * Search conversations
   */
  async searchConversations(
    query: string,
    limit: number = 20
  ): Promise<Array<{ conversation: Conversation; matching_messages: Message[] }>> {
    try {
      const params = new URLSearchParams()
      params.set('q', query)
      params.set('limit', limit.toString())

      const response = await fetch(`${this.baseUrl}/conversations/search/content?${params}`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to search conversations: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to search conversations:', error)
      return []
    }
  }

  /**
   * Get conversation statistics
   */
  async getConversationStats(): Promise<ConversationStats> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/stats/overview`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to fetch conversation stats: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to fetch conversation stats:', error)
      return {
        total_conversations: 0,
        active_conversations: 0,
        archived_conversations: 0,
        total_messages: 0,
        total_tokens_used: 0
      }
    }
  }

  /**
   * Get conversation settings
   */
  async getConversationSettings(): Promise<ConversationSettings> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/settings/preferences`, {
        method: 'GET',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to fetch conversation settings: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to fetch conversation settings:', error)
      return {
        auto_save_conversations: true,
        auto_generate_titles: true,
        max_conversations: 100,
        auto_archive_after_days: 30,
        default_provider: 'gemini',
        default_model: 'gemini-1.5-flash',
        save_curation_conversations: true,
        save_summary_conversations: true
      }
    }
  }

  /**
   * Update conversation settings
   */
  async updateConversationSettings(settings: Partial<ConversationSettings>): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/settings/preferences`, {
        method: 'PUT',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify(settings)
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to update conversation settings: ${response.status}`)
      }

      return true
    } catch (error) {
      console.error('API Client: Failed to update conversation settings:', error)
      return false
    }
  }

  /**
   * Archive old conversations
   */
  async archiveOldConversations(daysOld: number = 30): Promise<{ count: number; message: string }> {
    try {
      const response = await fetch(`${this.baseUrl}/conversations/cleanup/archive?days_old=${daysOld}`, {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        }
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Failed to archive conversations: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('API Client: Failed to archive conversations:', error)
      return { count: 0, message: 'Failed to archive conversations' }
    }
  }

  /**
   * Enhanced query method with conversation support and agentic RAG
   */
  async queryDocumentsWithConversation(
    question: string, 
    options: {
      hybrid?: boolean
      maxContext?: boolean
      documentIds?: string[]
      provider?: string
      model?: string
      conversationId?: string
      saveConversation?: boolean
      mode?: string // Add mode parameter for agentic RAG
    } = {}
  ): Promise<QueryResponse & { conversation_id?: string; reasoning_summary?: any }> {
    const { 
      hybrid = this.hybrid, 
      maxContext = false, 
      documentIds, 
      provider = 'gemini', 
      model,
      conversationId,
      saveConversation = true,
      mode = 'standard'
    } = options
    
    const url = new URL(`${this.baseUrl}/query`)
    url.searchParams.set('hybrid', hybrid.toString())
    url.searchParams.set('max_context', maxContext.toString())

    console.log('üéØ API Client: Enhanced query with agentic RAG support:', {
      mode,
      hybrid,
      provider,
      model,
      maxContext
    })

    try {
      const response = await fetch(url.toString(), {
        method: 'POST',
        headers: {
          ...this.getAuthHeaders(),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          question,
          document_ids: documentIds,
          provider: provider,
          model: model,
          conversation_id: conversationId,
          save_conversation: saveConversation,
          mode: mode // Include mode in request body
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || `Query failed: ${response.status}`)
      }

      return await response.json()
    } catch (error) {
      console.error('Query error:', error)
      throw error
    }
  }

  /**
   * Update configuration
   */
  updateConfig(config: {
    provider?: string
    hybrid?: boolean
    baseUrl?: string
  }) {
    if (config.provider) this.provider = config.provider
    if (config.hybrid !== undefined) this.hybrid = config.hybrid
    if (config.baseUrl) this.baseUrl = config.baseUrl
  }
}

// Export singleton instance
export const ragApiClient = new RagApiClient()
