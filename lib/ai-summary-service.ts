/**
 * AI Summary Service - Frontend service for managing AI-generated summaries
 * Mirrors the AI Curation service functionality for summaries
 */

import { ragApiClient } from './api-client';

// Types for AI Summary system
export interface AISummary {
  id: string;
  title: string;
  description: string;
  summaryType: 'auto' | 'individual' | 'combined' | 'custom' | 'thematic';
  keywords: string[];
  documentCount: number;
  confidence: number;
  status: 'active' | 'stale' | 'archived' | 'updating';
  lastUpdated: string;
  autoGenerated: boolean;
  generationMethod: string;
  contentLength: number;
  content: string;
}

export interface SummarySettings {
  autoRefresh: boolean;
  onAdd: 'full' | 'incremental' | 'manual';
  onDelete: 'auto_clean' | 'keep_stale' | 'prompt';
  changeThreshold: number;
  maxSummaries: number;
  minDocumentsPerSummary: number;
  defaultSummaryType: 'auto' | 'individual' | 'combined';
  includeIndividual: boolean;
  includeCombined: boolean;
}

export interface SummaryStatus {
  totalSummaries: number;
  activeSummaries: number;
  staleSummaries: number;
  archivedSummaries: number;
  needsUpdate: boolean;
  lastGenerated: string | null;
}

export interface SummaryGenerationResult {
  success: boolean;
  message: string;
  summaries: AISummary[];
  stats: {
    documentsProcessed: number;
    summariesCreated: number;
    summariesUpdated: number;
    summariesDeleted: number;
    processingTimeMs: number;
  };
}

export interface CustomSummaryRequest {
  title: string;
  description?: string;
  keywords?: string[];
  focusArea?: string;
  provider?: string;
  model?: string;
  documentIds?: string[]; // Add this to specify which documents to use
}

export interface SummaryContent {
  id: string;
  title: string;
  content: string;
  contentLength: number;
  lastUpdated: string;
}

class AISummaryService {
  private baseUrl = '/summaries';

  /**
   * Initialize the AI Summary service
   * This method can be used to set up any necessary configurations or cache
   */
  async initialize(): Promise<void> {
    try {
      console.log('üîÑ AI Summary Service: Initializing...')
      
      // Optionally pre-load summary settings or status for better performance
      // This is a lightweight operation that doesn't require heavy processing
      await this.getSummaryStatus()
      
      console.log('‚úÖ AI Summary Service: Initialized successfully')
    } catch (error) {
      console.warn('‚ö†Ô∏è AI Summary Service: Initialization failed, but service will still work:', error)
      // Don't throw error - service should still be usable even if initialization fails
    }
  }

  /**
   * Get all summaries for the current user
   */
  async getUserSummaries(): Promise<AISummary[]> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}`, {
        method: 'GET',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        if (response.status === 404) {
          console.log('No summaries found, returning empty array');
          return [];
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to fetch user summaries:', error);
      // Return empty array instead of throwing to prevent UI crashes
      return [];
    }
  }

  /**
   * Generate or regenerate summaries for the user
   */
  async generateSummaries(
    generationType: string = 'manual',
    triggerEvent: string = 'manual_refresh'
  ): Promise<SummaryGenerationResult> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/generate`, {
        method: 'POST',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          generationType,
          triggerEvent
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to generate summaries:', error);
      throw new Error('Failed to generate summaries');
    }
  }

  /**
   * Get summary settings for the current user
   */
  async getSummarySettings(): Promise<SummarySettings> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/settings`, {
        method: 'GET',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to fetch summary settings:', error);
      throw new Error('Failed to fetch summary settings');
    }
  }

  /**
   * Update summary settings for the current user
   */
  async updateSummarySettings(settings: Partial<SummarySettings>): Promise<{
    success: boolean;
    message: string;
    settings: SummarySettings;
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/settings`, {
        method: 'PUT',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(settings)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to update summary settings:', error);
      throw new Error('Failed to update summary settings');
    }
  }

  /**
   * Get the current status of summaries for the user
   */
  async getSummaryStatus(): Promise<SummaryStatus> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/status`, {
        method: 'GET',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to fetch summary status:', error);
      throw new Error('Failed to fetch summary status');
    }
  }

  /**
   * Create a custom summary with user-defined focus and keywords
   * Supports both object parameter and individual parameters for backward compatibility
   */
  async createCustomSummary(
    titleOrRequest: string | CustomSummaryRequest,
    description?: string,
    summaryType?: string,
    provider?: string,
    model?: string
  ): Promise<{
    success: boolean;
    message: string;
    summary?: AISummary;
  }> {
    try {
      let request: CustomSummaryRequest;

      // Handle both parameter styles
      if (typeof titleOrRequest === 'string') {
        // Individual parameters style
        request = {
          title: titleOrRequest,
          description: description,
          keywords: summaryType ? [summaryType] : [],
          provider: provider,
          model: model
        };
      } else {
        // Object parameter style
        request = titleOrRequest;
      }

      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/custom`, {
        method: 'POST',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to create custom summary:', error);
      throw new Error('Failed to create custom summary');
    }
  }

  /**
   * Get a specific summary by ID
   */
  async getSummaryById(summaryId: string): Promise<AISummary> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/${summaryId}`, {
        method: 'GET',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Failed to fetch summary ${summaryId}:`, error);
      throw new Error('Failed to fetch summary');
    }
  }

  /**
   * Delete a specific summary
   */
  async deleteSummary(summaryId: string): Promise<{
    success: boolean;
    message: string;
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/${summaryId}`, {
        method: 'DELETE',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Failed to delete summary ${summaryId}:`, error);
      throw new Error('Failed to delete summary');
    }
  }

  /**
   * Refresh a specific summary with new AI generation
   */
  async refreshSummary(
    summaryId: string,
    provider?: string,
    model?: string
  ): Promise<{
    success: boolean;
    message: string;
    summary: AISummary;
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/${summaryId}/refresh`, {
        method: 'POST',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          provider,
          model
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Failed to refresh summary ${summaryId}:`, error);
      throw new Error('Failed to refresh summary');
    }
  }

  /**
   * Get the full content of a specific summary
   */
  async getSummaryContent(summaryId: string): Promise<SummaryContent> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/${summaryId}/content`, {
        method: 'GET',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Failed to fetch summary content ${summaryId}:`, error);
      throw new Error('Failed to fetch summary content');
    }
  }

  /**
   * Generate content for a specific summary
   * This method generates or regenerates the content for a summary
   */
  async generateSummaryContent(summaryId: string): Promise<string> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/${summaryId}/generate-content`, {
        method: 'POST',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      return result.content || result.summary?.content || 'Summary content generated successfully';
    } catch (error) {
      console.error(`Failed to generate summary content ${summaryId}:`, error);
      throw new Error('Failed to generate summary content');
    }
  }

  /**
   * Delete multiple summaries at once
   */
  async bulkDeleteSummaries(summaryIds: string[]): Promise<{
    success: boolean;
    message: string;
    deletedCount: number;
    deletedTitles: string[];
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/bulk-delete`, {
        method: 'POST',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          summaryIds
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to bulk delete summaries:', error);
      throw new Error('Failed to delete summaries');
    }
  }

  /**
   * Archive all stale summaries for the user
   */
  async archiveStaleSummaries(): Promise<{
    success: boolean;
    message: string;
    archivedCount: number;
    archivedTitles: string[];
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/archive-stale`, {
        method: 'POST',
        headers: ragApiClient['getAuthHeaders']()
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to archive stale summaries:', error);
      throw new Error('Failed to archive stale summaries');
    }
  }

  /**
   * Handle summary updates when documents are added
   */
  async handleDocumentAddition(documentIds: string[]): Promise<{
    success: boolean;
    message: string;
    action: string;
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/handle-document-addition`, {
        method: 'POST',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          documentIds
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to handle document addition:', error);
      throw new Error('Failed to handle document addition');
    }
  }

  /**
   * Handle summary updates when documents are deleted
   */
  async handleDocumentDeletion(documentIds: string[]): Promise<{
    success: boolean;
    message: string;
    stats: {
      summariesUpdated: number;
      summariesDeleted: number;
      documentsRemoved: number;
    };
  }> {
    try {
      const response = await fetch(`${ragApiClient['baseUrl']}${this.baseUrl}/handle-document-deletion`, {
        method: 'POST',
        headers: {
          ...ragApiClient['getAuthHeaders'](),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          documentIds
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to handle document deletion:', error);
      throw new Error('Failed to handle document deletion');
    }
  }

  /**
   * Get summaries by type
   */
  async getSummariesByType(summaryType: string): Promise<AISummary[]> {
    try {
      const summaries = await this.getUserSummaries();
      return summaries.filter(summary => summary.summaryType === summaryType);
    } catch (error) {
      console.error(`Failed to fetch summaries by type ${summaryType}:`, error);
      throw new Error('Failed to fetch summaries by type');
    }
  }

  /**
   * Get summaries by status
   */
  async getSummariesByStatus(status: string): Promise<AISummary[]> {
    try {
      const summaries = await this.getUserSummaries();
      return summaries.filter(summary => summary.status === status);
    } catch (error) {
      console.error(`Failed to fetch summaries by status ${status}:`, error);
      throw new Error('Failed to fetch summaries by status');
    }
  }

  /**
   * Search summaries by keyword
   */
  async searchSummaries(keyword: string): Promise<AISummary[]> {
    try {
      const summaries = await this.getUserSummaries();
      const lowerKeyword = keyword.toLowerCase();

      return summaries.filter(summary =>
        summary.title.toLowerCase().includes(lowerKeyword) ||
        summary.description.toLowerCase().includes(lowerKeyword) ||
        summary.keywords.some(k => k.toLowerCase().includes(lowerKeyword)) ||
        summary.content.toLowerCase().includes(lowerKeyword)
      );
    } catch (error) {
      console.error(`Failed to search summaries with keyword ${keyword}:`, error);
      throw new Error('Failed to search summaries');
    }
  }

  /**
   * Get summary analytics
   */
  async getSummaryAnalytics(): Promise<{
    totalSummaries: number;
    summariesByType: Record<string, number>;
    summariesByStatus: Record<string, number>;
    averageConfidence: number;
    averageDocumentCount: number;
    averageContentLength: number;
    autoGeneratedCount: number;
    customCount: number;
  }> {
    try {
      const summaries = await this.getUserSummaries();

      const summariesByType: Record<string, number> = {};
      const summariesByStatus: Record<string, number> = {};
      let totalConfidence = 0;
      let totalDocumentCount = 0;
      let totalContentLength = 0;
      let autoGeneratedCount = 0;
      let customCount = 0;

      summaries.forEach(summary => {
        // Count by type
        summariesByType[summary.summaryType] = (summariesByType[summary.summaryType] || 0) + 1;

        // Count by status
        summariesByStatus[summary.status] = (summariesByStatus[summary.status] || 0) + 1;

        // Accumulate metrics
        totalConfidence += summary.confidence;
        totalDocumentCount += summary.documentCount;
        totalContentLength += summary.contentLength;

        if (summary.autoGenerated) {
          autoGeneratedCount++;
        } else {
          customCount++;
        }
      });

      return {
        totalSummaries: summaries.length,
        summariesByType,
        summariesByStatus,
        averageConfidence: summaries.length > 0 ? totalConfidence / summaries.length : 0,
        averageDocumentCount: summaries.length > 0 ? totalDocumentCount / summaries.length : 0,
        averageContentLength: summaries.length > 0 ? totalContentLength / summaries.length : 0,
        autoGeneratedCount,
        customCount
      };
    } catch (error) {
      console.error('Failed to get summary analytics:', error);
      throw new Error('Failed to get summary analytics');
    }
  }

  /**
   * Export summaries to various formats
   */
  async exportSummaries(format: 'json' | 'csv' | 'markdown' = 'json'): Promise<string> {
    try {
      const summaries = await this.getUserSummaries();

      switch (format) {
        case 'json':
          return JSON.stringify(summaries, null, 2);

        case 'csv':
          const headers = ['ID', 'Title', 'Type', 'Status', 'Confidence', 'Document Count', 'Last Updated'];
          const rows = summaries.map(s => [
            s.id,
            s.title,
            s.summaryType,
            s.status,
            s.confidence.toString(),
            s.documentCount.toString(),
            s.lastUpdated
          ]);
          return [headers, ...rows].map(row => row.join(',')).join('\n');

        case 'markdown':
          let markdown = '# AI Summaries Export\n\n';
          summaries.forEach(summary => {
            markdown += `## ${summary.title}\n\n`;
            markdown += `- **Type**: ${summary.summaryType}\n`;
            markdown += `- **Status**: ${summary.status}\n`;
            markdown += `- **Confidence**: ${(summary.confidence * 100).toFixed(1)}%\n`;
            markdown += `- **Documents**: ${summary.documentCount}\n`;
            markdown += `- **Keywords**: ${summary.keywords.join(', ')}\n`;
            markdown += `- **Last Updated**: ${new Date(summary.lastUpdated).toLocaleString()}\n\n`;
            markdown += `### Content\n\n${summary.content}\n\n---\n\n`;
          });
          return markdown;

        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error(`Failed to export summaries in ${format} format:`, error);
      throw new Error('Failed to export summaries');
    }
  }

  /**
   * Validate summary settings
   */
  validateSummarySettings(settings: Partial<SummarySettings>): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (settings.changeThreshold !== undefined) {
      if (settings.changeThreshold < 0 || settings.changeThreshold > 100) {
        errors.push('Change threshold must be between 0 and 100');
      }
    }

    if (settings.maxSummaries !== undefined) {
      if (settings.maxSummaries < 1 || settings.maxSummaries > 50) {
        errors.push('Max summaries must be between 1 and 50');
      }
    }

    if (settings.minDocumentsPerSummary !== undefined) {
      if (settings.minDocumentsPerSummary < 1) {
        errors.push('Minimum documents per summary must be at least 1');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Get recommended settings based on user's document collection
   */
  async getRecommendedSettings(documentCount: number): Promise<Partial<SummarySettings>> {
    const recommendations: Partial<SummarySettings> = {};

    // Recommend settings based on document count
    if (documentCount <= 5) {
      recommendations.maxSummaries = 3;
      recommendations.defaultSummaryType = 'individual';
      recommendations.includeIndividual = true;
      recommendations.includeCombined = false;
    } else if (documentCount <= 20) {
      recommendations.maxSummaries = 6;
      recommendations.defaultSummaryType = 'auto';
      recommendations.includeIndividual = true;
      recommendations.includeCombined = true;
    } else {
      recommendations.maxSummaries = 8;
      recommendations.defaultSummaryType = 'combined';
      recommendations.includeIndividual = false;
      recommendations.includeCombined = true;
    }

    // Set other reasonable defaults
    recommendations.autoRefresh = true;
    recommendations.onAdd = 'incremental';
    recommendations.onDelete = 'auto_clean';
    recommendations.changeThreshold = 15;
    recommendations.minDocumentsPerSummary = 1;

    return recommendations;
  }
}

// Export singleton instance
export const aiSummaryService = new AISummaryService();
export default aiSummaryService;
