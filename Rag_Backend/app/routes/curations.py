"""
AI Curation API Routes
Provides endpoints for managing AI-generated document curations
"""

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlmodel import Session
from typing import List, Dict, Optional
from pydantic import BaseModel
import logging

from app.database import get_session
from app.deps import get_current_user
from app.database import User
from app.services.curation_service import curation_service
from app.models import Document

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/curations", tags=["curations"])

# Request/Response Models
class CurationSettingsRequest(BaseModel):
    autoRefresh: Optional[bool] = None
    onAdd: Optional[str] = None  # full, incremental, manual
    onDelete: Optional[str] = None  # auto_clean, keep_stale, prompt
    changeThreshold: Optional[int] = None
    maxCurations: Optional[int] = None
    minDocumentsPerCuration: Optional[int] = None

class CurationGenerateRequest(BaseModel):
    force: bool = False
    generationType: str = "manual"  # manual, full, incremental

class CustomCurationRequest(BaseModel):
    title: str
    description: Optional[str] = None
    keywords: List[str] = []
    provider: str = "gemini"
    model: str = "gemini-1.5-flash"

class CurationResponse(BaseModel):
    id: str
    title: str
    description: Optional[str]
    keywords: List[str]
    documentCount: int
    confidence: float
    status: str
    lastUpdated: str
    autoGenerated: bool
    generationMethod: Optional[str] = None

class CurationStatsResponse(BaseModel):
    totalCurations: int
    activeCurations: int
    staleCurations: int
    archivedCurations: int
    needsUpdate: bool
    lastGenerated: Optional[str]

class CurationSettingsResponse(BaseModel):
    autoRefresh: bool
    onAdd: str
    onDelete: str
    changeThreshold: int
    maxCurations: int
    minDocumentsPerCuration: int

class CurationGenerationResponse(BaseModel):
    success: bool
    message: str
    curations: List[CurationResponse]
    stats: Dict

@router.get("/", response_model=List[CurationResponse])
async def get_user_curations(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get all active curations for the current user"""
    try:
        curations = await curation_service.get_user_curations(str(user.id), session)
        return curations
    except Exception as e:
        logger.error(f"Failed to get curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curations: {str(e)}")

@router.get("/status", response_model=CurationStatsResponse)
async def get_curation_status(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get the current status of curations for the user"""
    try:
        status = await curation_service.get_curation_status(str(user.id), session)
        return status
    except Exception as e:
        logger.error(f"Failed to get curation status for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation status: {str(e)}")

@router.get("/settings", response_model=CurationSettingsResponse)
async def get_curation_settings(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get curation settings for the current user"""
    try:
        settings = await curation_service.get_user_settings(str(user.id), session)
        return settings
    except Exception as e:
        logger.error(f"Failed to get curation settings for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation settings: {str(e)}")

@router.put("/settings", response_model=CurationSettingsResponse)
async def update_curation_settings(
    settings_request: CurationSettingsRequest,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Update curation settings for the current user"""
    try:
        # Convert Pydantic model to dict, excluding None values
        settings_data = settings_request.dict(exclude_none=True)
        
        updated_settings = await curation_service.update_user_settings(
            str(user.id), settings_data, session
        )
        return updated_settings
    except Exception as e:
        logger.error(f"Failed to update curation settings for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update curation settings: {str(e)}")

@router.post("/generate", response_model=CurationGenerationResponse)
async def generate_curations(
    request: CurationGenerateRequest,
    background_tasks: BackgroundTasks,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Generate or regenerate curations for the current user"""
    try:
        logger.info(f"Generating curations for user {user.id} (type: {request.generationType})")
        
        result = await curation_service.generate_curations_for_user(
            str(user.id), 
            session,
            generation_type=request.generationType,
            trigger_event="manual_refresh"
        )
        
        return result
    except Exception as e:
        logger.error(f"Failed to generate curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate curations: {str(e)}")

@router.post("/refresh")
async def refresh_curations(
    background_tasks: BackgroundTasks,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Refresh all curations for the current user (convenience endpoint)"""
    try:
        result = await curation_service.generate_curations_for_user(
            str(user.id), 
            session,
            generation_type="full",
            trigger_event="manual_refresh"
        )
        
        return {
            "success": result["success"],
            "message": result["message"],
            "stats": result["stats"]
        }
    except Exception as e:
        logger.error(f"Failed to refresh curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to refresh curations: {str(e)}")

@router.delete("/{curation_id}")
async def delete_curation(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Delete a specific curation"""
    try:
        from sqlmodel import select
        from app.models import AICuration, DocumentCurationMapping
        from sqlalchemy import and_
        
        # Find the curation
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Delete associated mappings
        mapping_statement = select(DocumentCurationMapping).where(
            and_(
                DocumentCurationMapping.curation_id == curation_id,
                DocumentCurationMapping.owner_id == str(user.id)
            )
        )
        mappings = session.exec(mapping_statement).all()
        
        for mapping in mappings:
            session.delete(mapping)
        
        # Delete the curation
        session.delete(curation)
        session.commit()
        
        return {
            "success": True,
            "message": f"Curation '{curation.title}' deleted successfully",
            "deletedMappings": len(mappings)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete curation {curation_id} for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to delete curation: {str(e)}")

@router.get("/{curation_id}")
async def get_curation_details(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get detailed information about a specific curation"""
    try:
        from sqlmodel import select
        from app.models import AICuration, DocumentCurationMapping, Document
        from sqlalchemy import and_
        
        # Find the curation
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Get associated documents with relevance scores
        mapping_statement = select(DocumentCurationMapping, Document).join(
            Document, DocumentCurationMapping.document_id == Document.id
        ).where(
            and_(
                DocumentCurationMapping.curation_id == curation_id,
                DocumentCurationMapping.owner_id == str(user.id)
            )
        )
        
        mappings_and_docs = session.exec(mapping_statement).all()
        
        documents = []
        for mapping, doc in mappings_and_docs:
            documents.append({
                "id": doc.id,
                "name": doc.filename,
                "relevanceScore": mapping.relevance_score,
                "keywordsMatched": mapping.keywords_matched,
                "summary": doc.summary
            })
        
        return {
            "id": curation.id,
            "title": curation.title,
            "description": curation.description,
            "keywords": curation.topic_keywords,
            "documentCount": curation.document_count,
            "confidence": curation.confidence_score,
            "status": curation.status,
            "lastUpdated": curation.last_updated.isoformat(),
            "autoGenerated": curation.auto_generated,
            "generationMethod": curation.generation_method,
            "documents": documents,
            "createdAt": curation.created_at.isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get curation details {curation_id} for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation details: {str(e)}")

@router.post("/{curation_id}/refresh")
async def refresh_specific_curation(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Refresh a specific curation by regenerating it"""
    try:
        from sqlmodel import select
        from app.models import AICuration
        from sqlalchemy import and_
        
        # Find the curation
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Mark as updating
        curation.status = 'updating'
        session.commit()
        
        try:
            # Regenerate all curations (for now - could be optimized to regenerate just this one)
            result = await curation_service.generate_curations_for_user(
                str(user.id), 
                session,
                generation_type="manual",
                trigger_event="curation_refresh"
            )
            
            return {
                "success": True,
                "message": f"Curation '{curation.title}' refreshed successfully",
                "stats": result.get("stats", {})
            }
            
        except Exception as e:
            # Reset status on failure
            curation.status = 'stale'
            session.commit()
            raise e
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to refresh curation {curation_id} for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to refresh curation: {str(e)}")

# Internal endpoints for document lifecycle integration
@router.post("/internal/document-added")
async def handle_document_added(
    document_ids: List[str],
    user_id: str,
    session: Session = Depends(get_session)
):
    """Internal endpoint called when documents are added"""
    try:
        result = await curation_service.handle_document_addition(
            user_id, document_ids, session
        )
        return result
    except Exception as e:
        logger.error(f"Failed to handle document addition for user {user_id}: {e}")
        return {
            "success": False,
            "message": f"Failed to handle document addition: {str(e)}"
        }

@router.post("/custom", response_model=CurationResponse)
async def create_custom_curation(
    request: CustomCurationRequest,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Create a custom AI curation with user-defined topic and keywords"""
    try:
        logger.info(f"Creating custom curation for user {user.id}: {request.title}")
        
        # Create the custom curation
        result = await curation_service.create_custom_curation(
            str(user.id),
            session,
            title=request.title,
            description=request.description,
            keywords=request.keywords,
            provider=request.provider,
            model=request.model
        )
        
        if result["success"]:
            return result["curation"]
        else:
            raise HTTPException(status_code=400, detail=result["message"])
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to create custom curation for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to create custom curation: {str(e)}")

@router.post("/internal/document-deleted")
async def handle_document_deleted(
    document_ids: List[str],
    user_id: str,
    session: Session = Depends(get_session)
):
    """Internal endpoint called when documents are deleted"""
    try:
        result = await curation_service.handle_document_deletion(
            user_id, document_ids, session
        )
        return result
    except Exception as e:
        logger.error(f"Failed to handle document deletion for user {user_id}: {e}")
        return {
            "success": False,
            "message": f"Failed to handle document deletion: {str(e)}"
        }
