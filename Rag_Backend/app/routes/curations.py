"""
AI Curation API Routes
Provides endpoints for managing AI-generated document curations
"""

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlmodel import Session
from typing import List, Dict, Optional
from pydantic import BaseModel
import logging

from app.database import get_session
from app.deps import get_current_user
from app.database import User
from app.services.curation_service import curation_service
from app.models import Document

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/curations", tags=["curations"], redirect_slashes=False)

# Request/Response Models
class CurationSettingsRequest(BaseModel):
    autoRefresh: Optional[bool] = None
    onAdd: Optional[str] = None  # full, incremental, manual
    onDelete: Optional[str] = None  # auto_clean, keep_stale, prompt
    changeThreshold: Optional[int] = None
    maxCurations: Optional[int] = None
    minDocumentsPerCuration: Optional[int] = None

class CurationGenerateRequest(BaseModel):
    force: bool = False
    generationType: str = "manual"  # manual, full, incremental

class CustomCurationRequest(BaseModel):
    title: str
    description: Optional[str] = None
    keywords: List[str] = []
    provider: str = "gemini"
    model: str = "gemini-1.5-flash"

class CurationResponse(BaseModel):
    id: str
    title: str
    description: Optional[str]
    keywords: List[str]
    documentCount: int
    confidence: float
    status: str
    lastUpdated: str
    autoGenerated: bool
    generationMethod: Optional[str] = None

class CurationStatsResponse(BaseModel):
    totalCurations: int
    activeCurations: int
    staleCurations: int
    archivedCurations: int
    needsUpdate: bool
    lastGenerated: Optional[str]

class CurationSettingsResponse(BaseModel):
    autoRefresh: bool
    onAdd: str
    onDelete: str
    changeThreshold: int
    maxCurations: int
    minDocumentsPerCuration: int

class CurationGenerationResponse(BaseModel):
    success: bool
    message: str
    curations: List[CurationResponse]
    stats: Dict

@router.get("", response_model=List[CurationResponse])
async def get_user_curations(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get all active curations for the current user"""
    try:
        curations = await curation_service.get_user_curations(str(user.id), session)
        return curations
    except Exception as e:
        logger.error(f"Failed to get curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curations: {str(e)}")

@router.get("/shared-from-admin", response_model=List[CurationResponse])
async def get_shared_admin_curations(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get curations that have been shared by admin users in the same account"""
    # ENHANCED DEBUG: Add immediate response to verify route is being hit
    print(f"üö®üö®üö® SHARED-FROM-ADMIN ROUTE ENTRY POINT HIT! üö®üö®üö®")
    logger.error(f"üö® SHARED-FROM-ADMIN: Route handler called successfully!")
    
    try:
        from sqlmodel import select
        from app.models import AICuration
        from app.database import User as DBUser
        from sqlalchemy import and_
        import datetime as dt
        
        print(f"üéØüéØüéØ SHARED-FROM-ADMIN ROUTE HIT! USER: {user.id} ({user.email}) üéØüéØüéØ")
        logger.error(f"üéØ SHARED-FROM-ADMIN: Route successfully called by user {user.id} ({user.email})")
        print(f"üìç Route path: /curations/shared-from-admin")
        print(f"üìç HTTP method: GET")
        print(f"üìç User is_admin: {getattr(user, 'is_admin', 'UNKNOWN')}")
        
        # Skip for admin users - they don't need to see shared curations
        if hasattr(user, 'is_admin') and user.is_admin:
            logger.info(f"Admin user {user.id} requesting shared curations - returning empty list")
            return []
        
        # Get all admin users in the same tenant - using the main users table
        admin_users_statement = select(DBUser).where(
            and_(
                DBUser.tenant_id == user.tenant_id,
                DBUser.is_admin == True
            )
        )
        admin_users = session.exec(admin_users_statement).all()
        admin_user_ids = [str(admin.id) for admin in admin_users]
        
        logger.info(f"Found {len(admin_users)} admin users in tenant {user.tenant_id}: {[admin.email for admin in admin_users]}")
        
        if not admin_user_ids:
            logger.info(f"No admin users found in tenant {user.tenant_id}")
            return []
        
        # Get shared curations from admin users
        shared_curations_statement = select(AICuration).where(
            and_(
                AICuration.owner_id.in_(admin_user_ids),
                AICuration.shared_with_account == True,
                AICuration.status == 'active'
            )
        )
        shared_curations = session.exec(shared_curations_statement).all()
        
        logger.info(f"Found {len(shared_curations)} shared curations from admin users")
        
        # Convert to response format
        curations_response = []
        for curation in shared_curations:
            logger.info(f"Processing shared curation: {curation.title} (ID: {curation.id})")
            curations_response.append(CurationResponse(
                id=curation.id,
                title=curation.title,
                description=curation.description,
                keywords=curation.topic_keywords or [],
                documentCount=curation.document_count,
                confidence=curation.confidence_score,
                status=curation.status,
                lastUpdated=curation.last_updated.isoformat(),
                autoGenerated=curation.auto_generated,
                generationMethod=curation.generation_method
            ))
        
        logger.info(f"User {user.id} retrieved {len(curations_response)} shared admin curations")
        return curations_response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get shared admin curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get shared admin curations: {str(e)}")

@router.get("/status", response_model=CurationStatsResponse)
async def get_curation_status(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get the current status of curations for the user"""
    try:
        status = await curation_service.get_curation_status(str(user.id), session)
        return status
    except Exception as e:
        logger.error(f"Failed to get curation status for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation status: {str(e)}")

@router.get("/settings", response_model=CurationSettingsResponse)
async def get_curation_settings(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get curation settings for the current user"""
    try:
        settings = await curation_service.get_user_settings(str(user.id), session)
        return settings
    except Exception as e:
        logger.error(f"Failed to get curation settings for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation settings: {str(e)}")

@router.put("/settings", response_model=CurationSettingsResponse)
async def update_curation_settings(
    settings_request: CurationSettingsRequest,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Update curation settings for the current user"""
    try:
        # Convert Pydantic model to dict, excluding None values
        settings_data = settings_request.dict(exclude_none=True)
        
        updated_settings = await curation_service.update_user_settings(
            str(user.id), settings_data, session
        )
        return updated_settings
    except Exception as e:
        logger.error(f"Failed to update curation settings for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update curation settings: {str(e)}")

@router.post("/generate", response_model=CurationGenerationResponse)
async def generate_curations(
    request: CurationGenerateRequest,
    background_tasks: BackgroundTasks,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Generate or regenerate curations for the current user"""
    try:
        logger.info(f"Generating curations for user {user.id} (type: {request.generationType})")
        
        result = await curation_service.generate_curations_for_user(
            str(user.id), 
            session,
            generation_type=request.generationType,
            trigger_event="manual_refresh"
        )
        
        return result
    except Exception as e:
        logger.error(f"Failed to generate curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate curations: {str(e)}")

@router.post("/refresh")
async def refresh_curations(
    background_tasks: BackgroundTasks,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Refresh all curations for the current user (convenience endpoint)"""
    try:
        result = await curation_service.generate_curations_for_user(
            str(user.id), 
            session,
            generation_type="full",
            trigger_event="manual_refresh"
        )
        
        return {
            "success": result["success"],
            "message": result["message"],
            "stats": result["stats"]
        }
    except Exception as e:
        logger.error(f"Failed to refresh curations for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to refresh curations: {str(e)}")

@router.delete("/{curation_id}")
async def delete_curation(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Delete a specific curation with comprehensive cleanup"""
    # Store user_id early to avoid session issues in error handling
    user_id = str(user.id)
    
    try:
        # Use the enhanced deletion service method
        result = await curation_service.delete_curation_completely(
            curation_id, user_id, session
        )
        
        if result["success"]:
            logger.info(f"Successfully deleted curation {curation_id} for user {user_id}")
            return result
        else:
            if result.get("not_found"):
                raise HTTPException(status_code=404, detail=result["message"])
            else:
                raise HTTPException(status_code=500, detail=result["message"])
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete curation {curation_id} for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to delete curation: {str(e)}")

@router.get("/{curation_id}")
async def get_curation_details(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get detailed information about a specific curation"""
    try:
        from sqlmodel import select
        from app.models import AICuration, DocumentCurationMapping, Document
        from sqlalchemy import and_
        
        # Find the curation
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Get associated documents with relevance scores
        mapping_statement = select(DocumentCurationMapping, Document).join(
            Document, DocumentCurationMapping.document_id == Document.id
        ).where(
            and_(
                DocumentCurationMapping.curation_id == curation_id,
                DocumentCurationMapping.owner_id == str(user.id)
            )
        )
        
        mappings_and_docs = session.exec(mapping_statement).all()
        
        documents = []
        for mapping, doc in mappings_and_docs:
            documents.append({
                "id": doc.id,
                "name": doc.filename,
                "relevanceScore": mapping.relevance_score,
                "keywordsMatched": mapping.keywords_matched,
                "summary": doc.summary
            })
        
        return {
            "id": curation.id,
            "title": curation.title,
            "description": curation.description,
            "keywords": curation.topic_keywords,
            "documentCount": curation.document_count,
            "confidence": curation.confidence_score,
            "status": curation.status,
            "lastUpdated": curation.last_updated.isoformat(),
            "autoGenerated": curation.auto_generated,
            "generationMethod": curation.generation_method,
            "documents": documents,
            "createdAt": curation.created_at.isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get curation details {curation_id} for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation details: {str(e)}")

@router.post("/{curation_id}/refresh")
async def refresh_specific_curation(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Refresh a specific curation by regenerating it"""
    try:
        from sqlmodel import select
        from app.models import AICuration
        from sqlalchemy import and_
        
        # Find the curation
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Mark as updating
        curation.status = 'updating'
        session.commit()
        
        try:
            # Regenerate all curations (for now - could be optimized to regenerate just this one)
            result = await curation_service.generate_curations_for_user(
                str(user.id), 
                session,
                generation_type="manual",
                trigger_event="curation_refresh"
            )
            
            return {
                "success": True,
                "message": f"Curation '{curation.title}' refreshed successfully",
                "stats": result.get("stats", {})
            }
            
        except Exception as e:
            # Reset status on failure
            curation.status = 'stale'
            session.commit()
            raise e
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to refresh curation {curation_id} for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to refresh curation: {str(e)}")

# Internal endpoints for document lifecycle integration
@router.post("/internal/document-added")
async def handle_document_added(
    document_ids: List[str],
    user_id: str,
    session: Session = Depends(get_session)
):
    """Internal endpoint called when documents are added"""
    try:
        result = await curation_service.handle_document_addition(
            user_id, document_ids, session
        )
        return result
    except Exception as e:
        logger.error(f"Failed to handle document addition for user {user_id}: {e}")
        return {
            "success": False,
            "message": f"Failed to handle document addition: {str(e)}"
        }

@router.get("/{curation_id}/content")
async def get_curation_content(
    curation_id: str,
    provider: str = "gemini",
    model: str = "gemini-1.5-flash",
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Get stored content for a specific curation or generate if not exists"""
    try:
        from sqlmodel import select
        from app.models import AICuration
        from app.database import User as DBUser
        from sqlalchemy import and_, or_
        
        # Enhanced access logic: Allow access to own curations OR shared admin curations in same tenant
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                or_(
                    # User owns the curation
                    AICuration.owner_id == str(user.id),
                    # OR it's a shared admin curation in the same tenant
                    and_(
                        AICuration.shared_with_account == True,
                        AICuration.tenant_id == user.tenant_id,
                        AICuration.status == 'active'
                    )
                )
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            logger.warning(f"Curation {curation_id} not found or not accessible to user {user.id}")
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Check if this is a shared curation from admin
        is_shared_admin_curation = (curation.owner_id != str(user.id) and 
                                  curation.shared_with_account and 
                                  curation.tenant_id == user.tenant_id)
        
        if is_shared_admin_curation:
            logger.info(f"User {user.id} accessing shared admin curation {curation_id}")
        
        # If content already exists and is generated, return it instantly
        if curation.content and curation.content_generated:
            logger.info(f"Returning stored content for curation {curation_id} (shared: {is_shared_admin_curation})")
            return {
                "success": True,
                "content": curation.content,
                "message": "Content retrieved from database",
                "cached": True,
                "is_shared": is_shared_admin_curation
            }
        
        # If no content exists, generate it and save to database
        # For shared curations, we still try to generate content using the original owner's context
        owner_id_for_generation = curation.owner_id if is_shared_admin_curation else str(user.id)
        
        logger.info(f"No stored content found for curation {curation_id}, generating new content (owner: {owner_id_for_generation})")
        result = await curation_service.generate_curation_content(
            curation_id,
            owner_id_for_generation,
            session,
            provider=provider,
            model=model
        )
        
        if result["success"]:
            return {
                "success": True,
                "content": result["content"],
                "message": result["message"],
                "cached": False,
                "is_shared": is_shared_admin_curation
            }
        else:
            raise HTTPException(status_code=400, detail=result["message"])
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get curation content {curation_id} for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get curation content: {str(e)}")

@router.put("/{curation_id}/content")
async def update_curation_content(
    curation_id: str,
    content: dict,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Update the content of a specific curation with user edits - ADMIN ONLY"""
    try:
        from sqlmodel import select
        from app.models import AICuration
        from sqlalchemy import and_
        import datetime as dt
        
        # ADMIN ONLY: Only admin users can edit curations
        if not hasattr(user, 'is_admin') or not user.is_admin:
            logger.warning(f"Non-admin user {user.id} ({user.email}) attempted to edit curation {curation_id}")
            raise HTTPException(status_code=403, detail="Only admin users can edit curations")
        
        # Validate request body
        if "content" not in content:
            raise HTTPException(status_code=400, detail="Content field is required")
        
        updated_content = content["content"]
        if not isinstance(updated_content, str) or not updated_content.strip():
            raise HTTPException(status_code=400, detail="Content must be a non-empty string")
        
        # Admin users can only edit their own curations
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            logger.warning(f"Curation {curation_id} not found or not owned by admin user {user.id}")
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Store original content for potential rollback
        original_content = curation.content
        
        # Update the curation content
        curation.content = updated_content.strip()
        curation.content_generated = True
        curation.last_updated = dt.datetime.utcnow()
        curation.status = "active"  # Mark as active since it's been updated
        
        # Add edit metadata if provided
        if "title" in content and content["title"].strip():
            curation.title = content["title"].strip()
        
        if "description" in content and content["description"]:
            curation.description = content["description"].strip()
        
        try:
            session.commit()
            session.refresh(curation)
            
            logger.info(f"Successfully updated content for curation {curation_id} by admin user {user.id}")
            
            return {
                "success": True,
                "message": "Curation content updated successfully",
                "curation": {
                    "id": curation.id,
                    "title": curation.title,
                    "description": curation.description,
                    "content": curation.content,
                    "lastUpdated": curation.last_updated.isoformat(),
                    "status": curation.status
                }
            }
            
        except Exception as db_error:
            # Rollback on database error
            session.rollback()
            logger.error(f"Database error updating curation {curation_id}: {db_error}")
            raise HTTPException(status_code=500, detail="Failed to save changes to database")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to update curation content {curation_id} for admin user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update curation content: {str(e)}")

@router.post("/custom", response_model=CurationResponse)
async def create_custom_curation(
    request: CustomCurationRequest,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Create a custom AI curation with user-defined topic and keywords"""
    try:
        logger.info(f"Creating custom curation for user {user.id}: {request.title}")
        
        # Create the custom curation
        result = await curation_service.create_custom_curation(
            str(user.id),
            session,
            title=request.title,
            description=request.description,
            keywords=request.keywords,
            provider=request.provider,
            model=request.model
        )
        
        if result["success"]:
            # Automatically generate content for the new curation
            content_result = await curation_service.generate_curation_content(
                result["curation"]["id"],
                str(user.id),
                session,
                provider=request.provider,
                model=request.model
            )
            
            if content_result["success"]:
                logger.info(f"Generated content for new custom curation {result['curation']['id']}")
            
            return result["curation"]
        else:
            raise HTTPException(status_code=400, detail=result["message"])
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to create custom curation for user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to create custom curation: {str(e)}")

@router.post("/internal/document-deleted")
async def handle_document_deleted(
    document_ids: List[str],
    user_id: str,
    session: Session = Depends(get_session)
):
    """Internal endpoint called when documents are deleted"""
    try:
        result = await curation_service.handle_document_deletion(
            user_id, document_ids, session
        )
        return result
    except Exception as e:
        logger.error(f"Failed to handle document deletion for user {user_id}: {e}")
        return {
            "success": False,
            "message": f"Failed to handle document deletion: {str(e)}"
        }

@router.post("/{curation_id}/share-with-account")
async def share_curation_with_account_users(
    curation_id: str,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    """Share an admin curation with all users in the account"""
    try:
        from sqlmodel import select
        from app.models import AICuration
        from app.tenant_models import TenantUser
        from sqlalchemy import and_
        import datetime as dt
        
        # Check if user is admin
        if not hasattr(user, 'is_admin') or not user.is_admin:
            raise HTTPException(status_code=403, detail="Only admin users can share curations with account users")
        
        # Find the curation
        statement = select(AICuration).where(
            and_(
                AICuration.id == curation_id,
                AICuration.owner_id == str(user.id)
            )
        )
        curation = session.exec(statement).first()
        
        if not curation:
            raise HTTPException(status_code=404, detail="Curation not found")
        
        # Get all users in the same tenant (account)
        account_users_statement = select(TenantUser).where(
            TenantUser.tenant_id == user.tenant_id
        )
        account_users = session.exec(account_users_statement).all()
        
        # Mark curation as shared with account
        curation.shared_with_account = True
        curation.shared_at = dt.datetime.utcnow()
        curation.shared_by = str(user.id)
        
        session.commit()
        session.refresh(curation)
        
        shared_count = len(account_users)
        logger.info(f"Admin user {user.id} shared curation {curation_id} with {shared_count} account users")
        
        return {
            "success": True,
            "message": f"Curation '{curation.title}' has been shared with {shared_count} users in your account",
            "details": {
                "curation_id": curation_id,
                "curation_title": curation.title,
                "shared_with_count": shared_count,
                "shared_at": curation.shared_at.isoformat()
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to share curation {curation_id} for admin user {user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to share curation: {str(e)}")
